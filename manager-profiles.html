<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Manager Profile ‚Äì LWFFL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      /* Dark Navy Theme */
      --bg-main: #020617;
      --card-bg: #020617;
      --accent: #38bdf8;
      --accent-dim: rgba(56, 189, 248, 0.15);
      --border-subtle: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;

      --positive: #22c55e;
      --negative: #ef4444;
      --warning: #f59e0b;

      /* Money: make $$$ green */
      --money: #22c55e;

      /* Badges */
      --gold: #fbbf24;
      --gold-bg: rgba(251, 191, 36, 0.1);
      --silver: #cbd5e1;
      --silver-bg: rgba(203, 213, 225, 0.1);
      --bronze: #d97706;
      --bronze-bg: rgba(217, 119, 6, 0.1);
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 35%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 24px 16px;
    }

    .shell { max-width: 1200px; margin: 0 auto; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #020617; }
    ::-webkit-scrollbar-thumb { background: #1f2937; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #374151; }

    /* --- Controls --- */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
      gap: 16px;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #f9fafb;
    }

    .manager-select-wrapper { position: relative; min-width: 250px; }

    select {
      width: 100%;
      padding: 10px 14px;
      background-color: #0b1120;
      border: 1px solid rgba(75, 85, 99, 0.9);
      border-radius: 10px;
      color: #f9fafb;
      font-size: 0.95rem;
      font-weight: 500;
      appearance: none;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.7);
      transition: border-color 0.15s;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%239ca3af'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 14px center;
      background-size: 16px;
    }
    select:focus { border-color: var(--accent); outline: none; box-shadow: 0 0 0 1px var(--accent); }

    /* --- Common Card Style --- */
    .card {
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), transparent 55%),
        var(--card-bg);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      position: relative;
      overflow: hidden;
      margin-bottom: 24px;
      backdrop-filter: blur(14px);
    }

    /* 1. Horizontal Hero Card */
    .hero-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 32px;
      padding: 32px 40px;
      background:
        radial-gradient(circle at top right, rgba(56, 189, 248, 0.15), transparent 60%),
        var(--card-bg);
    }

    .hero-identity {
      display: flex;
      align-items: center;
      gap: 24px;
      flex: 1.2;
      min-width: 260px;
    }

    .avatar {
      width: 90px;
      height: 90px;
      flex: 0 0 90px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(56,189,248,0.2), rgba(2,6,23,0.8));
      border: 2px solid var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.2rem;
      font-weight: 800;
      color: #fff;
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.2);
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .hero-text { display: flex; flex-direction: column; min-width: 0; }
    
    .hero-name {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      margin-bottom: 4px;
      color: #f9fafb;
      line-height: 1.1;
      white-space: normal;
      word-wrap: break-word;
      max-width: 520px;
    }

    .hero-tenure {
      display: inline-block;
      color: var(--text-muted);
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    /* Middle: Trophy Case */
    .trophy-case {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      flex: 1.5;
      justify-content: center;
      border-left: 1px solid var(--border-subtle);
      border-right: 1px solid var(--border-subtle);
      padding: 0 32px;
      min-width: 260px;
    }

    .trophy-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .trophy-badge.gold { background: var(--gold-bg); color: var(--gold); border-color: rgba(251, 191, 36, 0.3); }
    .trophy-badge.silver { background: var(--silver-bg); color: var(--silver); border-color: rgba(203, 213, 225, 0.3); }
    .trophy-badge.bronze { background: var(--bronze-bg); color: var(--bronze); border-color: rgba(217, 119, 6, 0.3); }
    .trophy-badge.scoring { background: rgba(59, 130, 246, 0.16); color: #93c5fd; border-color: rgba(59, 130, 246, 0.35); }

    .empty-case { font-size: 0.85rem; color: var(--text-soft); font-style: italic; }

    /* Right: OVR Rating & Attributes */
    .rating-container { display: flex; align-items: center; gap: 20px; flex: 1; justify-content: flex-end; min-width: 260px; }
    .sub-ratings { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; min-width: 180px; }
    .sub-stat {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      font-size: 0.8rem;
      color: var(--text-muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .sub-stat span:last-child { color: var(--accent); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.9rem; }

    .ovr-badge { display: flex; flex-direction: column; align-items: center; flex: 0 0 auto; }
    .ovr-ring {
      width: 75px; height: 75px;
      border-radius: 50%;
      border: 3px solid var(--accent);
      display: flex;
      align-items: center; justify-content: center;
      box-shadow: 0 0 25px rgba(56, 189, 248, 0.2);
      background: rgba(2, 6, 23, 0.8);
      flex: 0 0 auto;
    }
    .ovr-val { font-size: 2.2rem; font-weight: 900; color: #fff; }
    .ovr-label { font-size: 0.75rem; font-weight: 700; color: var(--accent); margin-top: 8px; letter-spacing: 0.2em; }

    /* 2. Stats Strip */
    .stats-strip { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px; }
    .stat-box {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0,0,0,0.2);
    }
    .stat-label { font-size: 0.7rem; text-transform: uppercase; font-weight: 700; color: var(--text-muted); letter-spacing: 0.1em; margin-bottom: 6px; }
    .stat-val { font-size: 1.4rem; font-weight: 700; color: #f9fafb; line-height: 1; margin-bottom: 4px; }
    .stat-sub { font-size: 0.75rem; color: var(--text-soft); display: none; }

    /* 3. Analytics Grid */
    .analytics-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px; margin-bottom: 24px; }

    .chart-card { min-height: 350px; display: flex; flex-direction: column; }
    .chart-header {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid var(--border-subtle);
      padding-bottom: 12px;
    }
    .chart-header h3 {
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--text-main);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .chart-icon { color: var(--accent); font-size: 1.1rem; }
    .chart-container { position: relative; flex: 1; width: 100%; min-height: 220px; }

    /* Rivalry Cards */
    .rivalry-col { display: flex; flex-direction: column; gap: 20px; }

    .rival-card {
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid var(--border-subtle);
      border-left: 4px solid var(--border-subtle);
      padding: 16px 20px;
      border-radius: 4px 12px 12px 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .rival-card.nemesis { border-left-color: var(--negative); }
    .rival-card.pigeon { border-left-color: var(--positive); }
    .rival-meta { display: flex; flex-direction: column; }
    .rival-type { font-size: 0.7rem; text-transform: uppercase; font-weight: 700; letter-spacing: 0.1em; color: var(--text-soft); margin-bottom: 4px; }
    .rival-name { font-size: 1.1rem; font-weight: 600; color: #f9fafb; }
    .rival-stat { text-align: right; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-weight: 700; font-size: 1.1rem; }
    .nemesis .rival-stat { color: var(--negative); }
    .pigeon .rival-stat { color: var(--positive); }

    /* Last 10 sparkline */
    .form-card { grid-column: 1 / -1; }
    .form-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .form-strip {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 6px;
    }
    .form-dot {
      width: 18px;
      height: 18px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(148, 163, 184, 0.2);
      position: relative;
      flex: 0 0 auto;
      transition: transform 0.12s;
      outline: none;
    }
    .form-dot[data-res="W"] { background: rgba(34, 197, 94, 0.95); border-color: rgba(34, 197, 94, 0.35); }
    .form-dot[data-res="L"] { background: rgba(239, 68, 68, 0.95); border-color: rgba(239, 68, 68, 0.35); }
    .form-dot[data-res="T"] { background: rgba(245, 158, 11, 0.95); border-color: rgba(245, 158, 11, 0.35); }
    .form-dot:hover, .form-dot:focus { transform: scale(1.12); border-color: rgba(255,255,255,0.35); }

    .form-dot::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 140%;
      left: 50%;
      transform: translateX(-50%);
      background: #000;
      border: 1px solid var(--border-subtle);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      box-shadow: 0 6px 16px rgba(0,0,0,0.55);
      z-index: 10;
    }
    .form-dot:hover::after, .form-dot:focus::after { opacity: 1; }

    .form-meta {
      display: flex;
      align-items: baseline;
      gap: 12px;
      white-space: nowrap;
    }
    .form-meta .label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 800;
      color: var(--text-muted);
    }
    .form-meta .rec {
      font-family: monospace;
      font-weight: 800;
      color: #f9fafb;
      font-size: 0.95rem;
    }

    /* --- High/Low Ticker Styles --- */
    .hl-ticker {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 10px 0;
    }
    .hl-row {
      display: flex;
      align-items: center;
      gap: 15px;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border-subtle);
      padding: 10px 14px;
      border-radius: 8px;
    }
    .hl-icon {
      font-size: 1.2rem;
      flex: 0 0 30px;
      text-align: center;
    }
    .hl-data { display: flex; flex-direction: column; }
    .hl-score { font-size: 1.2rem; font-weight: 800; line-height: 1; color: #fff; }
    .hl-meta { font-size: 0.75rem; color: var(--text-muted); margin-top: 4px; }
    .hl-high .hl-icon, .hl-high .hl-score { color: var(--positive); }
    .hl-low .hl-icon, .hl-low .hl-score { color: var(--negative); }

    /* --- Fate Flow Styles --- */
    .fate-flow {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 0;
    }
    .fate-step {
      display: flex;
      align-items: center;
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
      height: 36px;
      position: relative;
      overflow: hidden;
    }
    .fate-bar {
      height: 100%;
      background: rgba(56, 189, 248, 0.2);
      border-right: 2px solid var(--accent);
      transition: width 0.5s ease-out;
    }
    .fate-label {
      position: absolute;
      left: 12px;
      font-size: 0.75rem;
      font-weight: 700;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      z-index: 2;
    }
    .fate-val {
      position: absolute;
      right: 12px;
      font-size: 0.85rem;
      font-family: monospace;
      color: var(--accent);
      font-weight: 700;
      z-index: 2;
    }
    .step-playoffs .fate-bar { background: rgba(56,189,248,0.2); border-color: var(--accent); }
    .step-finals .fate-bar { background: rgba(251,191,36,0.15); border-color: var(--gold); }
    .step-titles .fate-bar { background: rgba(34,197,94,0.2); border-color: var(--positive); }
    .step-finals .fate-val { color: var(--gold); }
    .step-titles .fate-val { color: var(--positive); }

    /* --- Tables --- */
    .table-wrap { border: 1px solid var(--border-subtle); border-radius: 12px; overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; min-width: 700px; font-size: 0.9rem; }
    th {
      background: rgba(15, 23, 42, 0.95);
      text-align: left;
      padding: 12px 16px;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border-subtle);
    }
    td {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.5);
      color: #ffffff; 
      font-variant-numeric: tabular-nums;
    }
    tr:last-child td { border-bottom: none; }
    tbody tr:hover { background: rgba(56, 189, 248, 0.03); }

    /* Skeleton Loading */
    .skeleton {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      color: transparent !important;
      position: relative;
      overflow: hidden;
    }
    .skeleton::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.05), transparent);
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

    /* Responsive */
    @media (max-width: 1024px) {
      .hero-card { flex-wrap: wrap; padding: 24px; gap: 24px; }
      .trophy-case {
        border-left: none; padding-left: 0;
        border-right: none; padding-right: 0;
        border-top: 1px solid var(--border-subtle);
        padding-top: 20px;
        width: 100%;
        flex: 100%;
      }
      .rating-container {
        width: 100%;
        justify-content: space-between;
        border-top: 1px solid var(--border-subtle);
        padding-top: 20px;
      }
      .hero-name { max-width: 100%; }
    }

    @media (max-width: 768px) {
      .hero-card { flex-direction: column; text-align: center; gap: 20px; align-items: center; }
      .hero-identity { flex-direction: column; text-align: center; gap: 12px; min-width: unset; }
      .rating-container { flex-direction: column; gap: 20px; min-width: unset; }
      .trophy-case { justify-content: center; min-width: unset; }

      .stats-strip { grid-template-columns: 1fr 1fr; }
      .analytics-grid { grid-template-columns: 1fr; }
      .chart-card { min-height: 320px; }
      .form-row { justify-content: center; }
    }
  </style>
</head>

<body>
  <div class="shell">

    <div class="top-bar">
      <div class="page-title">Manager Profile</div>
      <div class="manager-select-wrapper">
        <select id="managerSelect" aria-label="Select Manager"></select>
      </div>
    </div>

    <div class="card hero-card">
      <div class="hero-identity">
        <div class="avatar" id="heroAvatar"></div>
        <div class="hero-text">
          <div class="hero-name" id="heroName"><span class="skeleton">Loading Name</span></div>
          <div class="hero-tenure" id="heroTenure"><span class="skeleton">EST. 20XX</span></div>
        </div>
      </div>

      <div class="trophy-case" id="trophyCase"></div>

      <div class="rating-container">
        <div class="sub-ratings">
          <div class="sub-stat"><span>SCOR</span> <span id="ratingSCOR">-</span></div>
          <div class="sub-stat"><span>GM</span> <span id="ratingGM">-</span></div>
          <div class="sub-stat"><span>CLT</span> <span id="ratingCLT">-</span></div>
          <div class="sub-stat"><span>STB</span> <span id="ratingSTB">-</span></div>
        </div>
        <div class="ovr-badge">
          <div class="ovr-ring">
            <span class="ovr-val" id="heroOvr">--</span>
          </div>
          <span class="ovr-label">OVR</span>
        </div>
      </div>
    </div>

    <div class="stats-strip">
      <div class="stat-box">
        <span class="stat-label">Career Record</span>
        <span class="stat-val" id="statRecord">-</span>
        <span class="stat-sub" id="statWinPct">Win %</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Avg Finish</span>
        <span class="stat-val" id="statAvgFinish">-</span>
        <span class="stat-sub">Rank</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Avg Score</span>
        <span class="stat-val" id="statAvgScore">-</span>
        <span class="stat-sub">PTS/Game</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Earnings</span>
        <span class="stat-val" id="statEarnings" style="color:var(--money)">-</span>
        <span class="stat-sub">Total Won</span>
      </div>
    </div>

    <div class="analytics-grid">
      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">‚ú¶</div>
          <h3>Luck Index (Quadrants)</h3>
        </div>
        <div class="chart-container">
          <canvas id="luckChart"></canvas>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üìä</div>
          <h3>Scoring Spread (Low/High)</h3>
        </div>
        <div class="chart-container">
          <canvas id="spreadChart"></canvas>
        </div>
      </div>

      <div class="rivalry-col">
        <div class="rival-card pigeon">
          <div class="rival-meta">
            <span class="rival-type">Pigeon (Highest Win %)</span>
            <span class="rival-name" id="pigeonName">-</span>
          </div>
          <span class="rival-stat" id="pigeonStat">-</span>
        </div>

        <div class="rival-card nemesis">
          <div class="rival-meta">
            <span class="rival-type">Nemesis (Lowest Win %)</span>
            <span class="rival-name" id="nemesisName">-</span>
          </div>
          <span class="rival-stat" id="nemesisStat">-</span>
        </div>

        <div class="card" style="margin-bottom:0; padding:16px;">
          <div class="chart-header" style="margin-bottom:10px;">
            <div class="chart-icon">‚Üï</div>
            <h3>All-Time Highs & Lows</h3>
          </div>
          <div class="hl-ticker" id="hlTicker"></div>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üìà</div>
          <h3>Career Trajectory</h3>
        </div>
        <div class="chart-container">
          <canvas id="careerChart"></canvas>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üèÅ</div>
          <h3>Post-Season Fate</h3>
        </div>
        <div class="chart-container" style="display:flex; flex-direction:column; justify-content:center;">
          <div id="fateFlow" class="fate-flow"></div>
        </div>
      </div>
<div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üíì</div>
          <h3>Heart Attack Ratio (Games < 5 pts)</h3>
        </div>
        <div class="chart-container">
          <canvas id="heartChart"></canvas>
        </div>
      </div>
</div>

    <div class="card">
      <div class="table-wrap">
        <table id="seasonTable">
          <thead>
            <tr>
              <th>Year</th>
              <th>Record</th>
              <th>Finish</th>
              <th>Points For</th>
              <th>Points Against</th>
              <th>Seed</th>
              <th>Earnings</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

  </div>

  <script>
    // --- Constants & Global State ---
    let rawScores = [], rawStandings = [], rawSeeds = [];
    const charts = {};
    const leagueRatings = {};

    // Cached DOM
    const $ = (id) => document.getElementById(id);
    const els = {};

    // --- Helpers ---
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const safeNum = (v, fallback = 0) => Number.isFinite(Number(v)) ? Number(v) : fallback;
    const moneyFmt = (n) => `$${Number(n || 0).toLocaleString()}`;
    const keyMY = (m, y) => `${m}::${y}`;

    // Shrink very long names so they fit in two lines in the hero header.
    function fitHeroName() {
      const el = els.heroName;
      if (!el) return;
      // Reset to CSS-defined size first
      el.style.fontSize = '';
      el.style.lineHeight = '';
      const cs = window.getComputedStyle(el);
      const lineHeight = parseFloat(cs.lineHeight) || (parseFloat(cs.fontSize) * 1.1);
      const maxHeight = lineHeight * 2 + 1; // 2 lines (small buffer)
      // If it overflows, step font size down slightly until it fits (or hits a floor)
      let fs = parseFloat(cs.fontSize) || 32;
      const minFs = 20;
      while (el.scrollHeight > maxHeight && fs > minFs) {
        fs -= 1;
        el.style.fontSize = fs + 'px';
        el.style.lineHeight = '1.1';
      }
    }

    // --- Dynamic Earnings Calculation ---
    // Pot multipliers based on Buy-In History:
    // 2014-2017: $20 (Factor 1.0)
    // 2018-2019: $40 (Factor 2.0)
    // 2020:      $50 (Factor 2.5)
    // 2021+:     $75 (Factor 3.75)
    
    function getEarnings(year, rank, hasScoringTitle, isFinalsApp) {
      let multiplier = 3.75; // Default (2021+)
      if (year <= 2017) multiplier = 1.0;
      else if (year <= 2019) multiplier = 2.0;
      else if (year === 2020) multiplier = 2.5;
      
      const baseSemis = 15 * multiplier;
      const baseFinalsApp = 20 * multiplier;
      const baseChamp = 120 * multiplier;
      const baseScoring = 20 * multiplier;
      
      let total = 0;
      
      // Structure:
      // 3rd/4th (Semis losers): Base Semis
      // 2nd: Base Semis + Base Finals App
      // 1st: Base Semis + Base Finals App + Base Champ
      
      if (rank <= 4) total += baseSemis;
      if (rank <= 2) total += baseFinalsApp;
      if (rank === 1) total += baseChamp;
      
      if (hasScoringTitle) total += baseScoring;
      
      return total;
    }

    function normalizeStandingsRow(s) {
      return {
        year: safeNum(s.year, null),
        manager: (s.manager ?? '').trim(),
        wins: safeNum(s.wins, 0),
        losses: safeNum(s.losses, 0),
        ties: safeNum(s.ties, 0),
        final_standing: safeNum((s.final_standing ?? s.finalStanding), null),
        division_finish: safeNum((s.division_finish ?? s.divisionFinish), null),
        points_for: safeNum((s.points_for ?? s.pointsFor), 0),
        points_against: safeNum((s.points_against ?? s.pointsAgainst), 0),
      };
    }

    function normalizeScoreRow(g) {
      return {
        year: safeNum(g.year, null),
        week: safeNum(g.week, null),
        manager1: (g.manager1 ?? '').trim(),
        manager2: (g.manager2 ?? '').trim(),
        score1: safeNum(g.score1, NaN),
        score2: safeNum(g.score2, NaN),
        playoffs: g.playoffs ?? "N/A"
      };
    }

    function calcStdDev(values) {
      if (!values.length) return 0;
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
      return Math.sqrt(variance);
    }

    // --- Indexes & Ranking Logic ---
    const idx = {
      managers: [],
      standingsByManager: new Map(),
      seedsByManagerYear: new Map(),
      gamesByManager: new Map(),
      weekBuckets: new Map(), 
      scoringTitlesByManager: new Map(),
      seasonRanks: {} 
    };

    function buildIndexes() {
      idx.managers = [];
      idx.standingsByManager.clear();
      idx.seedsByManagerYear.clear();
      idx.gamesByManager.clear();
      idx.weekBuckets.clear();
      idx.scoringTitlesByManager.clear();
      idx.seasonRanks = {};

      const managerSet = new Set();

      rawStandings.forEach(s => {
        if (!s.manager) return;
        managerSet.add(s.manager);
        if (!idx.standingsByManager.has(s.manager)) idx.standingsByManager.set(s.manager, []);
        idx.standingsByManager.get(s.manager).push(s);
      });
      idx.standingsByManager.forEach(arr => arr.sort((a, b) => b.year - a.year));

      rawSeeds.forEach(sd => {
        const m = (sd.manager ?? '').trim();
        const y = safeNum(sd.year, null);
        if (!m || !y) return;
        idx.seedsByManagerYear.set(keyMY(m, y), sd.seed);
        managerSet.add(m);
      });

      rawScores.forEach(row => {
        const g = normalizeScoreRow(row);
        if (!g.manager1 || !g.manager2) return;
        if (!Number.isFinite(g.score1) || !Number.isFinite(g.score2)) return;
        if (!Number.isFinite(g.year) || !Number.isFinite(g.week)) return;

        managerSet.add(g.manager1);
        managerSet.add(g.manager2);

        const bucketKey = `${g.year}::${g.week}`;
        if (!idx.weekBuckets.has(bucketKey)) idx.weekBuckets.set(bucketKey, []);
        idx.weekBuckets.get(bucketKey).push({ manager: g.manager1, score: g.score1, isPlayoff: (g.playoffs && g.playoffs !== "N/A") });
        idx.weekBuckets.get(bucketKey).push({ manager: g.manager2, score: g.score2, isPlayoff: (g.playoffs && g.playoffs !== "N/A") });

        const asGameFor = (name) => {
          const isAway = (g.manager1 === name);
          const myScore = isAway ? g.score1 : g.score2;
          const oppScore = isAway ? g.score2 : g.score1;
          const opponent = isAway ? g.manager2 : g.manager1;
          const result = myScore > oppScore ? 'W' : (myScore < oppScore ? 'L' : 'T');
          return {
            year: g.year,
            week: g.week,
            score: myScore,
            oppScore,
            opponent,
            result,
            isPlayoff: (g.playoffs && g.playoffs !== "N/A")
          };
        };

        [g.manager1, g.manager2].forEach(m => {
          if (!idx.gamesByManager.has(m)) idx.gamesByManager.set(m, []);
          idx.gamesByManager.get(m).push(asGameFor(m));
        });
      });

      idx.gamesByManager.forEach(arr => arr.sort((a, b) => (b.year !== a.year ? b.year - a.year : b.week - a.week)));
      idx.managers = Array.from(managerSet).sort((a, b) => a.localeCompare(b));

      const byYear = new Map();
      rawStandings.forEach(s => {
        if (!Number.isFinite(s.year) || !s.manager) return;
        if (!byYear.has(s.year)) byYear.set(s.year, []);
        byYear.get(s.year).push(s);
      });

      for (const [year, rows] of byYear.entries()) {
        rows.sort((a,b) => b.points_for - a.points_for);
        rows.forEach((r, i) => {
          const k = keyMY(r.manager, year);
          if(!idx.seasonRanks[k]) idx.seasonRanks[k] = {};
          idx.seasonRanks[k].pfRank = i + 1;
        });

        rows.sort((a,b) => b.points_against - a.points_against);
        rows.forEach((r, i) => {
          const k = keyMY(r.manager, year);
          if(!idx.seasonRanks[k]) idx.seasonRanks[k] = {};
          idx.seasonRanks[k].paRank = i + 1;
        });

        let maxPF = -Infinity;
        rows.forEach(r => { if (Number.isFinite(r.points_for)) maxPF = Math.max(maxPF, r.points_for); });
        if (Number.isFinite(maxPF) && maxPF > 0) {
          rows.forEach(r => {
            if (r.points_for === maxPF) {
              if (!idx.scoringTitlesByManager.has(r.manager)) idx.scoringTitlesByManager.set(r.manager, new Set());
              idx.scoringTitlesByManager.get(r.manager).add(year);
            }
          });
        }
      }
    }

    function calculateAllRatings() {
      const expectedWins = {};
      idx.managers.forEach(m => { expectedWins[m] = 0; });

      for (const [, entries] of idx.weekBuckets.entries()) {
        const byManager = new Map();
        entries.forEach(e => {
          if (!e.manager) return;
          if (!Number.isFinite(e.score)) return;
          byManager.set(e.manager, e.score);
        });

        const list = Array.from(byManager.entries()).map(([manager, score]) => ({ manager, score }));
        const N = list.length;
        if (N < 2) continue;

        for (let i = 0; i < N; i++) {
          const mi = list[i].manager;
          const si = list[i].score;
          let beat = 0, tie = 0;

          for (let j = 0; j < N; j++) {
            if (i === j) continue;
            const sj = list[j].score;
            if (si > sj) beat++;
            else if (si === sj) tie++;
          }
          expectedWins[mi] += (beat + 0.5 * tie) / (N - 1);
        }
      }

      const rows = idx.managers.map(m => {
        const seasons = idx.standingsByManager.get(m) || [];
        const games = idx.gamesByManager.get(m) || [];

        let wins = 0, ties = 0;
        let playGames = 0, playWins = 0;
        let totalPF = 0;

        games.forEach(g => {
          totalPF += g.score;
          if (g.result === 'W') wins++;
          else if (g.result === 'T') ties++;

          if (g.isPlayoff) {
            playGames++;
            if (g.result === 'W') playWins++;
          }
        });

        const actualW = wins + ties * 0.5;
        const expW = expectedWins[m] || 0;
        const gmRaw = actualW - expW;

        const ppm = games.length ? totalPF / games.length : 0;
        const cltRaw = playGames ? (playWins / playGames) : 0;

        const finishes = seasons.map(s => s.final_standing).filter(Number.isFinite);
        const stdDev = calcStdDev(finishes);

        const titles = seasons.filter(s => s.final_standing === 1).length;
        const runnerUps = seasons.filter(s => s.final_standing === 2).length;
        const thirds = seasons.filter(s => s.final_standing === 3).length;
        const divTitles = seasons.filter(s => s.division_finish === 1).length;
        const seedApps = seasons.reduce((acc, s) => acc + (idx.seedsByManagerYear.has(keyMY(m, s.year)) ? 1 : 0), 0);

        const hardwarePoints = (titles * 10) + (runnerUps * 6) + (thirds * 4) + (divTitles * 2) + (seedApps * 1);
        const legacyRaw = 12 * Math.log(1 + hardwarePoints); 

        return { name: m, ppm, gmRaw, cltRaw, stdDev, legacyRaw };
      });

      const ppmVals = rows.map(r => r.ppm).filter(Number.isFinite);
      const gmVals = rows.map(r => r.gmRaw).filter(Number.isFinite);
      const cltVals = rows.map(r => r.cltRaw).filter(Number.isFinite);
      const stbVals = rows.map(r => r.stdDev).filter(Number.isFinite);
      const legVals = rows.map(r => r.legacyRaw).filter(Number.isFinite);

      const min = (a) => Math.min(...a);
      const max = (a) => Math.max(...a);
      const scale01 = (v, lo, hi) => (hi > lo ? (v - lo) / (hi - lo) : 0.5);

      const ppmMin = min(ppmVals), ppmMax = max(ppmVals);
      const gmMin = min(gmVals), gmMax = max(gmVals);
      const cltMin = min(cltVals), cltMax = max(cltVals);
      const stbMin = min(stbVals), stbMax = max(stbVals);
      const legMin = min(legVals), legMax = max(legVals);

      rows.forEach(r => {
        const scor = Math.round(70 + scale01(r.ppm, ppmMin, ppmMax) * 29);                        
        const gm   = Math.round(70 + scale01(r.gmRaw, gmMin, gmMax) * 29);                        
        const clt  = Math.round(60 + scale01(r.cltRaw, cltMin, cltMax) * 39);                     
        const stb  = Math.round(60 + (1 - scale01(r.stdDev, stbMin, stbMax)) * 39);               
        const leg  = Math.round(60 + scale01(r.legacyRaw, legMin, legMax) * 39);                  

        const skill = (scor * 0.30) + (gm * 0.35) + (clt * 0.20) + (stb * 0.15);
        const ovr = Math.round(skill * 0.80 + leg * 0.20);

        leagueRatings[r.name] = {
          ovr: clamp(ovr, 60, 99),
          scor: clamp(scor, 60, 99),
          gm: clamp(gm, 60, 99),
          clt: clamp(clt, 60, 99),
          stb: clamp(stb, 60, 99)
        };
      });
    }

    function initManagerDropdown() {
      const select = els.managerSelect;
      select.innerHTML = '';
      idx.managers.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        select.appendChild(opt);
      });
      select.addEventListener('change', (e) => loadManager(e.target.value));
    }

    function loadManager(name) {
      const mySeasons = idx.standingsByManager.get(name) || [];
      const myGames = idx.gamesByManager.get(name) || [];

      const h2h = {};
      myGames.forEach(g => {
        if (!g.opponent) return;
        if (!h2h[g.opponent]) h2h[g.opponent] = { w: 0, l: 0, t: 0, games: 0 };
        h2h[g.opponent].games++;
        if (g.result === 'W') h2h[g.opponent].w++;
        else if (g.result === 'L') h2h[g.opponent].l++;
        else h2h[g.opponent].t++;
      });

      renderHero(name, mySeasons);
      renderStats(mySeasons, myGames, name);
      renderRivalries(h2h);
      renderSeasonTable(mySeasons, name);
      renderLuckChart(mySeasons, name);
      renderSpreadChart(myGames);
      renderClutchChart(myGames);
      renderCareerChart(mySeasons);
      renderFormStrip(myGames);
      
      renderHardwareChart(mySeasons);
      renderHeartAttackChart(myGames);
      renderHighLow(myGames);
      renderFateFlow(mySeasons, name);
    }

    function renderHero(name, seasons) {
      const initials = name.split(' ').filter(Boolean).map(n => n[0]).join('').substring(0, 2).toUpperCase();
      els.heroAvatar.textContent = initials;
      els.heroName.textContent = name;
      fitHeroName();

      if (seasons.length > 0) {
        const minYear = Math.min(...seasons.map(s => s.year).filter(Number.isFinite));
        els.heroTenure.textContent = Number.isFinite(minYear) ? `EST. ${minYear}` : `EST. ‚Äî`;
      } else {
        els.heroTenure.textContent = `EST. ‚Äî`;
      }

      const caseEl = els.trophyCase;
      caseEl.innerHTML = '';
      const trophies = [];

      seasons.forEach(s => {
        const rank = s.final_standing;
        if (rank === 1) trophies.push({ y: s.year, html: `<span class="trophy-badge gold">üèÜ ${s.year} Champion</span>` });
        else if (rank === 2) trophies.push({ y: s.year, html: `<span class="trophy-badge silver">ü•à ${s.year} Runner-up</span>` });
        else if (rank === 3) trophies.push({ y: s.year, html: `<span class="trophy-badge bronze">ü•â ${s.year} 3rd</span>` });
      });

      const scoringYears = idx.scoringTitlesByManager.get(name) ? Array.from(idx.scoringTitlesByManager.get(name)) : [];
      scoringYears.forEach(y => trophies.push({ y, html: `<span class="trophy-badge scoring">üí∞ ${y} Scoring Title</span>` }));

      trophies.sort((a, b) => (b.y ?? 0) - (a.y ?? 0));
      caseEl.innerHTML = trophies.length ? trophies.map(t => t.html).join('') : `<span class="empty-case">No hardware... yet.</span>`;

      const r = leagueRatings[name] || { ovr: 75, scor: 75, gm: 75, clt: 75, stb: 75 };

      const ovrEl = els.heroOvr;
      const target = r.ovr;
      let current = clamp(safeNum(ovrEl.textContent, 0), 0, target);

      const step = () => {
        current = Math.min(target, current + Math.max(1, Math.ceil(target / 40)));
        ovrEl.textContent = current;
        if (current < target) requestAnimationFrame(step);
      };
      step();

      els.ratingSCOR.textContent = r.scor;
      els.ratingGM.textContent = r.gm;
      els.ratingCLT.textContent = r.clt;
      els.ratingSTB.textContent = r.stb;
    }

    function renderStats(seasons, games, managerName) {
      const w = games.filter(g => g.result === 'W').length;
      const l = games.filter(g => g.result === 'L').length;
      const t = games.filter(g => g.result === 'T').length;

      els.statRecord.textContent = `${w}-${l}-${t}`;

      const pct = games.length ? (w + t * 0.5) / games.length : 0;
      els.statWinPct.textContent = pct.toFixed(3);

      const finishes = seasons.map(s => s.final_standing).filter(Number.isFinite);
      const avgFin = finishes.length ? finishes.reduce((a, b) => a + b, 0) / finishes.length : 0;
      els.statAvgFinish.textContent = avgFin > 0 ? avgFin.toFixed(1) : '-';

      const totalScore = games.reduce((a, g) => a + g.score, 0);
      const avgScore = games.length ? totalScore / games.length : 0;
      els.statAvgScore.textContent = avgScore.toFixed(1);

      let money = 0;
      seasons.forEach(s => {
        const hasScoring = (idx.scoringTitlesByManager.get(managerName) || new Set()).has(s.year);
        // We pass 'false' for isFinalsApp because we just infer rank based on payouts logic
        // Actually, if rank <= 2, they made finals.
        // We handle this inside getEarnings via rank
        money += getEarnings(s.year, s.final_standing, hasScoring);
      });
      els.statEarnings.textContent = moneyFmt(money);
      els.statEarnings.style.color = 'var(--money)';
    }

    function renderRivalries(h2h) {
      let nemesis = { name: '-', pct: 1.0, rec: '' };
      let pigeon = { name: '-', pct: 0.0, rec: '' };

      Object.keys(h2h).forEach(opp => {
        const d = h2h[opp];
        if (d.games < 5) return;
        const pct = (d.w + d.t * 0.5) / d.games;
        if (pct <= nemesis.pct) nemesis = { name: opp, pct, rec: `${d.w}-${d.l}` };
        if (pct >= pigeon.pct) pigeon = { name: opp, pct, rec: `${d.w}-${d.l}` };
      });

      els.nemesisName.textContent = nemesis.name;
      els.nemesisStat.textContent = nemesis.rec || '-';
      els.pigeonName.textContent = pigeon.name;
      els.pigeonStat.textContent = pigeon.rec || '-';
    }

    function renderSeasonTable(seasons, managerName) {
      const tbody = document.querySelector('#seasonTable tbody');
      tbody.innerHTML = '';
      const frag = document.createDocumentFragment();

      seasons.forEach(s => {
        const seed = idx.seedsByManagerYear.get(keyMY(managerName, s.year)) ?? '-';
        const rank = s.final_standing;
        
        const hasScoring = (idx.scoringTitlesByManager.get(managerName) || new Set()).has(s.year);
        const money = getEarnings(s.year, rank, hasScoring);

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${s.year ?? '-'}</td>
          <td>${s.wins}-${s.losses}-${s.ties}</td>
          <td>${Number.isFinite(rank) ? rank : '-'}</td>
          <td>${Math.round(s.points_for || 0).toLocaleString()}</td>
          <td>${Math.round(s.points_against || 0).toLocaleString()}</td>
          <td>${seed}</td>
          <td style="color:${money > 0 ? 'var(--money)' : 'inherit'}">${money > 0 ? moneyFmt(money) : '-'}</td>
        `;
        frag.appendChild(tr);
      });

      tbody.appendChild(frag);
    }

    function renderFormStrip(games) {
      const strip = els.formStrip;
      const recEl = els.formRecord;
      if (!strip || !recEl) return;
      strip.innerHTML = '';

      const last10 = [...games]
        .filter(g => Number.isFinite(g.year) && Number.isFinite(g.week))
        .sort((a, b) => (a.year !== b.year ? b.year - a.year : b.week - a.week))
        .slice(0, 10);

      let w = 0, l = 0, t = 0;
      last10.forEach(g => {
        if (g.result === 'W') w++;
        else if (g.result === 'L') l++;
        else t++;

        const dot = document.createElement('div');
        dot.className = 'form-dot';
        dot.dataset.res = g.result;
        dot.tabIndex = 0;

        const opp = g.opponent || '?';
        const score = Number.isFinite(g.score) ? g.score.toFixed(1) : '';
        const oppScore = Number.isFinite(g.oppScore) ? g.oppScore.toFixed(1) : '';
        dot.dataset.tooltip = `${g.year} Wk ${g.week}: ${g.result} vs ${opp} (${score}‚Äì${oppScore})`;

        strip.appendChild(dot);
      });

      recEl.textContent = last10.length ? `${w}-${l}-${t}` : '‚Äî';
    }

    // --- NEW: High/Low Render ---
    function renderHighLow(games) {
      const el = $('hlTicker');
      if(!el) return;
      
      const validGames = games.filter(g => Number.isFinite(g.score));
      if(!validGames.length) { el.innerHTML = ''; return; }
      
      validGames.sort((a,b) => b.score - a.score);
      const high = validGames[0];
      const low = validGames[validGames.length - 1];
      
      el.innerHTML = `
        <div class="hl-row hl-high">
          <div class="hl-icon">‚ñ≤</div>
          <div class="hl-data">
            <div class="hl-score">${high.score.toFixed(2)}</div>
            <div class="hl-meta">${high.year} Wk ${high.week} vs ${high.opponent}</div>
          </div>
        </div>
        <div class="hl-row hl-low">
          <div class="hl-icon">‚ñº</div>
          <div class="hl-data">
            <div class="hl-score">${low.score.toFixed(2)}</div>
            <div class="hl-meta">${low.year} Wk ${low.week} vs ${low.opponent}</div>
          </div>
        </div>
      `;
    }

    // --- NEW: Fate Flow Render ---
    function renderFateFlow(seasons, managerName) {
      const container = $('fateFlow');
      if(!container) return;
      
      let total = 0, playoffs = 0, finals = 0, titles = 0;
      
      seasons.forEach(s => {
        if(!Number.isFinite(s.year)) return;
        total++;
        const seed = idx.seedsByManagerYear.get(keyMY(managerName, s.year));
        const rank = s.final_standing;
        
        let madePlayoffs = false;
        if(seed) madePlayoffs = true;
        if(Number.isFinite(rank) && rank <= 6) madePlayoffs = true;
        
        if(madePlayoffs) playoffs++;
        if(Number.isFinite(rank)) {
          if(rank <= 2) finals++;
          if(rank === 1) titles++;
        }
      });
      
      const pctP = total ? (playoffs / total * 100) : 0;
      const pctF = total ? (finals / total * 100) : 0;
      const pctT = total ? (titles / total * 100) : 0;
      
      container.innerHTML = `
        <div class="fate-step">
          <div class="fate-bar" style="width:100%"></div>
          <div class="fate-label">Seasons Played</div>
          <div class="fate-val">${total}</div>
        </div>
        <div class="fate-step step-playoffs">
          <div class="fate-bar" style="width:${pctP}%"></div>
          <div class="fate-label">Made Playoffs</div>
          <div class="fate-val">${playoffs}</div>
        </div>
        <div class="fate-step step-finals">
          <div class="fate-bar" style="width:${pctF}%"></div>
          <div class="fate-label">Made Finals</div>
          <div class="fate-val">${finals}</div>
        </div>
        <div class="fate-step step-titles">
          <div class="fate-bar" style="width:${pctT}%"></div>
          <div class="fate-label">Champions</div>
          <div class="fate-val">${titles}</div>
        </div>
      `;
    }

    // --- Charts ---
    Chart.defaults.color = '#64748b';
    Chart.defaults.font.family = 'system-ui';
    const commonOptions = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } };

    function renderLuckChart(seasons, managerName) {
      const canvas = $('luckChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.luck) charts.luck.destroy();

      const points = seasons.map(s => {
        const k = keyMY(managerName, s.year);
        const ranks = idx.seasonRanks[k] || { pfRank: 6, paRank: 6 };
        return { x: ranks.pfRank, y: ranks.paRank, year: s.year };
      });

      const quadrantPlugin = {
        id: 'quadrants',
        beforeDraw(chart) {
          const { ctx, chartArea: { top, bottom, left, right } } = chart;
          const midX = (left + right) / 2;
          const midY = (top + bottom) / 2;
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(midX, top); ctx.lineTo(midX, bottom);
          ctx.moveTo(left, midY); ctx.lineTo(right, midY);
          ctx.stroke();
          ctx.font = '600 9px system-ui';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.textAlign = 'center';
          
          ctx.fillText("DOMINANT & LUCKY", (left + midX) / 2, top + 15);
          ctx.fillText("SUBPAR & LUCKY", (midX + right) / 2, top + 15);
          ctx.fillText("UNLUCKY / SHOOTOUTS", (left + midX) / 2, bottom - 10);
          ctx.fillText("SUBPAR & UNLUCKY", (midX + right) / 2, bottom - 10);

          ctx.restore();
        }
      };

      charts.luck = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            data: points,
            backgroundColor: 'rgba(56, 189, 248, 0.55)',
            borderColor: 'rgba(56, 189, 248, 0.9)',
            pointBorderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8
          }]
        },
        plugins: [quadrantPlugin],
        options: {
          ...commonOptions,
          scales: {
            x: {
              title: { display: true, text: 'PF Rank (1=Best)' },
              min: 0,
              max: 12,
              ticks: { stepSize: 1, callback: (v) => Number(v).toFixed(0) },
              grid: { display: false },
              reverse: false
            },
            y: {
              title: { display: true, text: 'PA Rank (1=Unlucky)' },
              min: 0,
              max: 12,
              ticks: { stepSize: 1, callback: (v) => Number(v).toFixed(0) },
              grid: { display: false },
              reverse: false
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: { callbacks: { label: (c) => `${c.raw.year}: PF #${c.raw.x} | PA #${c.raw.y}` } }
          }
        }
      });
    }

    function renderSpreadChart(games) {
      const canvas = $('spreadChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.spread) charts.spread.destroy();

      const years = [...new Set(games.map(g => g.year).filter(Number.isFinite))].sort((a, b) => a - b);
      const data = years.map(y => {
        const scores = games.filter(g => g.year === y).map(g => g.score).filter(Number.isFinite);
        if (!scores.length) return [0, 0];
        return [Math.min(...scores), Math.max(...scores)];
      });

      charts.spread = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: data,
            backgroundColor: 'rgba(56, 189, 248, 0.4)',
            borderWidth: 0,
            borderSkipped: false,
            borderRadius: 4,
            barPercentage: 0.6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { 
            legend: { display: false },
            tooltip: { callbacks: { label: (c) => `Range: ${c.raw[0]} - ${c.raw[1]}` } }
          },
          scales: { y: { grid: { color: 'rgba(255,255,255,0.05)' } }, x: { grid: { display: false } } }
        }
      });
    }

    function renderClutchChart(games) {
      const canvas = $('clutchChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.clutch) charts.clutch.destroy();

      const reg = games.filter(g => !g.isPlayoff).map(g => g.score).filter(Number.isFinite);
      const play = games.filter(g => g.isPlayoff).map(g => g.score).filter(Number.isFinite);

      const regAvg = reg.length ? reg.reduce((a, b) => a + b, 0) / reg.length : 0;
      const playAvg = play.length ? play.reduce((a, b) => a + b, 0) / play.length : 0;

      charts.clutch = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Regular Season', 'Playoffs'],
          datasets: [{ data: [regAvg, playAvg], backgroundColor: ['#38bdf8', '#fbbf24'], borderRadius: 4 }]
        },
        options: {
          ...commonOptions,
          indexAxis: 'y',
          scales: {
            x: { grid: { display: false }, ticks: { color: '#94a3b8' } },
            y: { grid: { display: false }, ticks: { color: '#fff', font: { weight: 'bold' } } }
          }
        }
      });
    }

    function renderCareerChart(seasons) {
      const canvas = $('careerChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.career) charts.career.destroy();

      const sorted = [...seasons].filter(s => Number.isFinite(s.year)).sort((a, b) => a.year - b.year);

      charts.career = new Chart(ctx, {
        type: 'line',
        data: {
          labels: sorted.map(s => s.year),
          datasets: [{
            data: sorted.map(s => Number.isFinite(s.final_standing) ? s.final_standing : null),
            borderColor: '#38bdf8',
            backgroundColor: 'rgba(56, 189, 248, 0.1)',
            borderWidth: 2,
            tension: 0.3,
            fill: true,
            pointBackgroundColor: '#0f172a',
            pointBorderColor: '#38bdf8',
            pointBorderWidth: 2
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            y: { reverse: false, min: 1, max: 12, grace: 0.4, ticks: { stepSize: 1 }, grid: { color: 'rgba(255,255,255,0.05)' } },
            x: { grid: { display: false } }
          }
        }
      });
    }

    function renderHeartAttackChart(games) {
      const canvas = $('heartChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.heart) charts.heart.destroy();

      let wins=0, losses=0;
      games.forEach(g => {
        if(Number.isFinite(g.score) && Number.isFinite(g.oppScore)) {
          const diff = Math.abs(g.score - g.oppScore);
          if(diff < 5) {
            if(g.result === 'W') wins++;
            else if(g.result === 'L') losses++;
          }
        }
      });

      charts.heart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: ['Wins', 'Losses'],
          datasets: [{
            data: [wins, losses],
            backgroundColor: ['#22c55e', '#ef4444'],
            borderWidth: 0,
            hoverOffset: 4
          }]
        },
        options: {
          ...commonOptions,
          cutout: '65%',
          plugins: {
            legend: { display: true, position: 'bottom', labels: { color: '#94a3b8' } }
          }
        }
      });
    }

    function renderHardwareChart(seasons) {
      const canvas = $('hardwareChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.hw) charts.hw.destroy();

      let g=0, s=0, b=0, none=0;
      seasons.forEach(row => {
        const r = row.final_standing;
        if(r === 1) g++;
        else if(r === 2) s++;
        else if(r === 3) b++;
        else none++;
      });

      charts.hw = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Career Finishes'],
          datasets: [
            { label: 'Gold', data: [g], backgroundColor: '#fbbf24', barThickness: 40 },
            { label: 'Silver', data: [s], backgroundColor: '#cbd5e1', barThickness: 40 },
            { label: 'Bronze', data: [b], backgroundColor: '#d97706', barThickness: 40 },
            { label: 'Other', data: [none], backgroundColor: '#334155', barThickness: 40 }
          ]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: true, position: 'bottom', labels: { color:'#94a3b8' } } },
          scales: {
            x: { stacked: true, grid: { display:false }, ticks:{ color:'#94a3b8', stepSize:1 } },
            y: { stacked: true, display: false }
          }
        }
      });
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', async () => {
      window.addEventListener('resize', () => { try { fitHeroName(); } catch(e){} });
      [
        'managerSelect', 'heroAvatar', 'heroName', 'heroTenure', 'trophyCase', 'heroOvr',
        'ratingSCOR', 'ratingGM', 'ratingCLT', 'ratingSTB',
        'statRecord', 'statWinPct', 'statAvgFinish', 'statAvgScore', 'statEarnings',
        'nemesisName', 'nemesisStat', 'pigeonName', 'pigeonStat',
        'formStrip', 'formRecord'
      ].forEach(id => els[id] = $(id));

      try {
        const [sRes, stRes, sdRes] = await Promise.all([
          fetch('league-scores.json'),
          fetch('final-standings.json'),
          fetch('playoff-seeds.json')
        ]);

        if (!sRes.ok || !stRes.ok || !sdRes.ok) {
          throw new Error(`Data load failed: scores=${sRes.status}, standings=${stRes.status}, seeds=${sdRes.status}`);
        }

        rawScores = (await sRes.json()) || [];
        rawStandings = ((await stRes.json()) || []).map(normalizeStandingsRow);
        rawSeeds = (await sdRes.json()) || [];

        buildIndexes();
        calculateAllRatings();
        initManagerDropdown();

        const firstMgr = els.managerSelect.options?.[0]?.value;
        if (firstMgr) loadManager(firstMgr);
        else showErrorCard("No managers found in your data files.");

      } catch (err) {
        console.error(err);
        showErrorCard("Unable to load league data. Please ensure JSON files are present and valid.");
      }
    });
  </script>
</body>
</html>
