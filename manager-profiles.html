<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Manager Profile ‚Äì LWFFL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      /* Dark Navy Theme */
      --bg-main: #020617;
      --card-bg: #020617;
      --accent: #38bdf8;
      --accent-dim: rgba(56, 189, 248, 0.15);
      --border-subtle: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;

      --positive: #22c55e;
      --negative: #ef4444;
      --warning: #f59e0b;

      /* Money: make $$$ green */
      --money: #22c55e;

      /* Badges */
      --gold: #fbbf24;
      --gold-bg: rgba(251, 191, 36, 0.1);
      --silver: #cbd5e1;
      --silver-bg: rgba(203, 213, 225, 0.1);
      --bronze: #d97706;
      --bronze-bg: rgba(217, 119, 6, 0.1);
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 35%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 24px 16px;
    }

    .shell { max-width: 1200px; margin: 0 auto; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #020617; }
    ::-webkit-scrollbar-thumb { background: #1f2937; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #374151; }

    /* --- Controls --- */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
      gap: 16px;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #f9fafb;
    }

    .manager-select-wrapper { position: relative; min-width: 250px; }

    select {
      width: 100%;
      padding: 10px 14px;
      background-color: #0b1120;
      border: 1px solid rgba(75, 85, 99, 0.9);
      border-radius: 10px;
      color: #f9fafb;
      font-size: 0.95rem;
      font-weight: 500;
      appearance: none;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.7);
      transition: border-color 0.15s;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%239ca3af'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 14px center;
      background-size: 16px;
    }
    select:focus { border-color: var(--accent); outline: none; box-shadow: 0 0 0 1px var(--accent); }

    /* --- Common Card Style --- */
    .card {
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), transparent 55%),
        var(--card-bg);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      position: relative;
      overflow: hidden;
      margin-bottom: 24px;
      backdrop-filter: blur(14px);
    }

    /* 1. Horizontal Hero Card */
    .hero-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 32px;
      padding: 32px 40px;
      background:
        radial-gradient(circle at top right, rgba(56, 189, 248, 0.15), transparent 60%),
        var(--card-bg);
    }

    .hero-identity {
      display: flex;
      align-items: center;
      gap: 24px;
      flex: 1.2;
      min-width: 260px;
    }

    .avatar {
      width: 90px;
      height: 90px;
      flex: 0 0 90px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(56,189,248,0.2), rgba(2,6,23,0.8));
      border: 2px solid var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.2rem;
      font-weight: 800;
      color: #fff;
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.2);
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .hero-text { display: flex; flex-direction: column; min-width: 0; }

    .hero-name {
      font-size: 2rem;
      font-weight: 800;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      margin-bottom: 4px;
      color: #f9fafb;
      line-height: 1.1;
      white-space: normal;
      word-wrap: break-word;
      max-width: 520px;
    }

    .hero-tenure {
      display: inline-block;
      color: var(--text-muted);
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    /* Middle: Trophy Case */
    .trophy-case {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      flex: 1.5;
      justify-content: center;
      border-left: 1px solid var(--border-subtle);
      border-right: 1px solid var(--border-subtle);
      padding: 0 32px;
      min-width: 260px;
    }

    .trophy-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .trophy-badge.gold { background: var(--gold-bg); color: var(--gold); border-color: rgba(251, 191, 36, 0.3); }
    .trophy-badge.silver { background: var(--silver-bg); color: var(--silver); border-color: rgba(203, 213, 225, 0.3); }
    .trophy-badge.bronze { background: var(--bronze-bg); color: var(--bronze); border-color: rgba(217, 119, 6, 0.3); }
    .trophy-badge.scoring { background: rgba(59, 130, 246, 0.16); color: #93c5fd; border-color: rgba(59, 130, 246, 0.35); }

    .empty-case { font-size: 0.85rem; color: var(--text-soft); font-style: italic; }

    /* Right: OVR Rating & Attributes */
    .rating-container { display: flex; align-items: center; gap: 20px; flex: 1; justify-content: flex-end; min-width: 260px; }
    .sub-ratings { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; min-width: 180px; }

    /* Smaller label text to accommodate longer subcategory names (feature request) */
    .sub-stat {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      font-size: 0.72rem;
      color: var(--text-muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .sub-stat span:last-child { color: var(--accent); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.9rem; }

    .ovr-badge { display: flex; flex-direction: column; align-items: center; flex: 0 0 auto; }
    .ovr-ring {
      width: 75px; height: 75px;
      border-radius: 50%;
      border: 3px solid var(--accent);
      display: flex;
      align-items: center; justify-content: center;
      box-shadow: 0 0 25px rgba(56, 189, 248, 0.2);
      background: rgba(2, 6, 23, 0.8);
      flex: 0 0 auto;
    }
    .ovr-val { font-size: 2.2rem; font-weight: 900; color: #fff; }
    .ovr-label { font-size: 0.75rem; font-weight: 700; color: var(--accent); margin-top: 8px; letter-spacing: 0.2em; }

    /* 2. Stats Strip */
    .stats-strip { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px; }
    .stat-box {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0,0,0,0.2);
    }
    .stat-label { font-size: 0.7rem; text-transform: uppercase; font-weight: 700; color: var(--text-muted); letter-spacing: 0.1em; margin-bottom: 6px; }
    .stat-val { font-size: 1.4rem; font-weight: 700; color: #f9fafb; line-height: 1; margin-bottom: 4px; }
    .stat-sub { font-size: 0.75rem; color: var(--text-soft); display: none; }

    /* 3. Analytics Grid */
    .analytics-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px; margin-bottom: 24px; }

    .chart-card { min-height: 350px; display: flex; flex-direction: column; }
    .chart-header {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid var(--border-subtle);
      padding-bottom: 12px;
    }
    .chart-header h3 {
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--text-main);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .chart-icon { color: var(--accent); font-size: 1.1rem; }
    .chart-container { position: relative; flex: 1; width: 100%; min-height: 220px; }

    /* Rivalry Cards */
    .rivalry-col { display: flex; flex-direction: column; gap: 20px; height: 100%; min-height: 350px; }

    .rival-card {
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid var(--border-subtle);
      border-left: 4px solid var(--border-subtle);
      padding: 16px 20px;
      border-radius: 4px 12px 12px 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .rival-card.nemesis { border-left-color: var(--negative); }
    .rival-card.pigeon { border-left-color: var(--positive); }
    .rival-meta { display: flex; flex-direction: column; }
    .rival-type { font-size: 0.7rem; text-transform: uppercase; font-weight: 700; letter-spacing: 0.1em; color: var(--text-soft); margin-bottom: 4px; }
    .rival-name { font-size: 1.1rem; font-weight: 600; color: #f9fafb; }
    .rival-stat { text-align: right; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-weight: 700; font-size: 1.1rem; }
    .nemesis .rival-stat { color: var(--negative); }
    .pigeon .rival-stat { color: var(--positive); }

    /* Last 10 sparkline */
    .form-card { grid-column: 1 / -1; }
    .form-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .form-strip {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 6px;
    }
    .form-dot {
      width: 18px;
      height: 18px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(148, 163, 184, 0.2);
      position: relative;
      flex: 0 0 auto;
      transition: transform 0.12s;
      outline: none;
    }
    .form-dot[data-res="W"] { background: rgba(34, 197, 94, 0.95); border-color: rgba(34, 197, 94, 0.35); }
    .form-dot[data-res="L"] { background: rgba(239, 68, 68, 0.95); border-color: rgba(239, 68, 68, 0.35); }
    .form-dot[data-res="T"] { background: rgba(245, 158, 11, 0.95); border-color: rgba(245, 158, 11, 0.35); }
    .form-dot:hover, .form-dot:focus { transform: scale(1.12); border-color: rgba(255,255,255,0.35); }

    .form-dot::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 140%;
      left: 50%;
      transform: translateX(-50%);
      background: #000;
      border: 1px solid var(--border-subtle);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      box-shadow: 0 6px 16px rgba(0,0,0,0.55);
      z-index: 10;
    }
    .form-dot:hover::after, .form-dot:focus::after { opacity: 1; }

    .form-meta {
      display: flex;
      align-items: baseline;
      gap: 12px;
      white-space: nowrap;
    }
    .form-meta .label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 800;
      color: var(--text-muted);
    }
    .form-meta .rec {
      font-family: monospace;
      font-weight: 800;
      color: #f9fafb;
      font-size: 0.95rem;
    }

    /* --- High/Low Ticker Styles --- */
    .hl-ticker {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 10px 0;
    }
    .hl-row {
      display: flex;
      align-items: center;
      gap: 15px;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border-subtle);
      padding: 10px 14px;
      border-radius: 8px;
    }
    .hl-icon {
      font-size: 1.2rem;
      flex: 0 0 30px;
      text-align: center;
    }
    .hl-data { display: flex; flex-direction: column; }
    .hl-score { font-size: 1.2rem; font-weight: 800; line-height: 1; color: #fff; }
    .hl-meta { font-size: 0.75rem; color: var(--text-muted); margin-top: 4px; }
    .hl-high .hl-icon, .hl-high .hl-score { color: var(--positive); }
    .hl-low .hl-icon, .hl-low .hl-score { color: var(--negative); }

    /* --- Fate Flow Styles --- */
    .fate-flow {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 0;
    }
    .fate-step {
      display: flex;
      align-items: center;
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
      height: 36px;
      position: relative;
      overflow: hidden;
    }
    .fate-bar {
      height: 100%;
      background: rgba(56, 189, 248, 0.2);
      border-right: 2px solid var(--accent);
      transition: width 0.5s ease-out;
    }
    .fate-label {
      position: absolute;
      left: 12px;
      font-size: 0.75rem;
      font-weight: 700;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      z-index: 2;
    }
    .fate-val {
      position: absolute;
      right: 12px;
      font-size: 0.85rem;
      font-family: monospace;
      color: var(--accent);
      font-weight: 700;
      z-index: 2;
    }

    /* Updated color semantics per request */
    .step-playoffs .fate-bar { background: rgba(217, 119, 6, 0.15); border-color: var(--bronze); }
    .step-finals .fate-bar { background: rgba(203, 213, 225, 0.12); border-color: var(--silver); }
    .step-titles .fate-bar { background: rgba(251, 191, 36, 0.15); border-color: var(--gold); }

    .step-playoffs .fate-val { color: var(--bronze); }
    .step-finals .fate-val { color: var(--silver); }
    .step-titles .fate-val { color: var(--gold); }

    /* --- Tables --- */
    .table-wrap { border: 1px solid var(--border-subtle); border-radius: 12px; overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; min-width: 700px; font-size: 0.9rem; }
    th {
      background: rgba(15, 23, 42, 0.95);
      text-align: left;
      padding: 12px 16px;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border-subtle);
    }
    td {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.5);
      color: #ffffff;
      font-variant-numeric: tabular-nums;
    }
    tr:last-child td { border-bottom: none; }
    tbody tr:hover { background: rgba(56, 189, 248, 0.03); }

    /* Skeleton Loading */
    .skeleton {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      color: transparent !important;
      position: relative;
      overflow: hidden;
    }
    .skeleton::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.05), transparent);
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

    /* Responsive */
    @media (max-width: 1024px) {
      .hero-card { flex-wrap: wrap; padding: 24px; gap: 24px; }
      .trophy-case {
        border-left: none; padding-left: 0;
        border-right: none; padding-right: 0;
        border-top: 1px solid var(--border-subtle);
        padding-top: 20px;
        width: 100%;
        flex: 100%;
      }
      .rating-container {
      display: flex;
      align-items: center;
      gap: 24px;
      flex: 1.25;
      justify-content: flex-end;
      min-width: 300px;
      }
      .hero-name { max-width: 100%; }
    }

    @media (max-width: 768px) {
      .hero-card { flex-direction: column; text-align: center; gap: 20px; align-items: center; }
      .hero-identity { flex-direction: column; text-align: center; gap: 12px; min-width: unset; }
      .rating-container { flex-direction: column; gap: 20px; min-width: unset; }
      .trophy-case { justify-content: center; min-width: unset; }

      .stats-strip { grid-template-columns: 1fr 1fr; }
      .analytics-grid { grid-template-columns: 1fr; }
      .chart-card { min-height: 320px; }
      .form-row { justify-content: center; }
    }
  </style>
</head>

<body>
  <div class="shell">

    <div class="top-bar">
      <div class="page-title">Manager Profile</div>
      <div class="manager-select-wrapper">
        <select id="managerSelect" aria-label="Select Manager"></select>
      </div>
    </div>

    <div class="card hero-card">
      <div class="hero-identity">
        <div class="avatar" id="heroAvatar"></div>
        <div class="hero-text">
          <div class="hero-name" id="heroName"><span class="skeleton">Loading Name</span></div>
          <div class="hero-tenure" id="heroTenure"><span class="skeleton">EST. 20XX</span></div>
        </div>
      </div>

      <div class="trophy-case" id="trophyCase"></div>

      <div class="rating-container">
        <div class="sub-ratings">
          <div class="sub-stat" title="Peak: Highest Elo reached across all tracked games."><span>Peak</span> <span id="ratingSCOR">-</span></div>
          <div class="sub-stat" title="Floor: Lowest Elo reached across all tracked games."><span>Floor</span> <span id="ratingGM">-</span></div>
          <div class="sub-stat" title="Œî Last 10: Elo change over the last 10 games (or since start if fewer than 10)."><span>Œî Last 10</span> <span id="ratingCLT">-</span></div>
          <div class="sub-stat" title="Rank: Current Elo rank (1 = highest)."><span>Rank</span> <span id="ratingSTB">-</span></div>
        </div>
        <div class="ovr-badge" title="ELO: Rating that updates after every matchup based on opponent strength, margin of victory, and playoff weighting.">
          <div class="ovr-ring">
            <span class="ovr-val" id="heroOvr">--</span>
          </div>
          <span class="ovr-label">ELO</span>
        </div>
      </div>
    </div>

    <div class="stats-strip">
      <div class="stat-box">
        <span class="stat-label">Career Record</span>
        <span class="stat-val" id="statRecord">-</span>
        <span class="stat-sub" id="statWinPct">Win %</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Avg Finish</span>
        <span class="stat-val" id="statAvgFinish">-</span>
        <span class="stat-sub">Rank</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Avg Score</span>
        <span class="stat-val" id="statAvgScore">-</span>
        <span class="stat-sub">PTS/Game</span>
      </div>
      <div class="stat-box">
        <span class="stat-label">Career Earnings</span>
        <span class="stat-val" id="statEarnings" style="color:var(--money)">-</span>
        <span class="stat-sub">Total Won</span>
      </div>
    </div>

    <div class="analytics-grid">
      <div class="rivalry-col">
        <div class="rival-card pigeon">
          <div class="rival-meta">
            <span class="rival-type">Pigeon (Highest Win %)</span>
            <span class="rival-name" id="pigeonName">-</span>
          </div>
          <span class="rival-stat" id="pigeonStat">-</span>
        </div>

        <div class="rival-card nemesis">
          <div class="rival-meta">
            <span class="rival-type">Nemesis (Lowest Win %)</span>
            <span class="rival-name" id="nemesisName">-</span>
          </div>
          <span class="rival-stat" id="nemesisStat">-</span>
        </div>

        <div class="card" style="margin-bottom:0; padding:16px;">
          <div class="chart-header" style="margin-bottom:10px;">
            <div class="chart-icon">‚Üï</div>
            <h3>All-Time Highs & Lows</h3>
          </div>
          <div class="hl-ticker" id="hlTicker"></div>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üíì</div>
          <h3>Heart Attack Ratio (Games &lt; 5 pts)</h3>
        </div>
        <div class="chart-container">
          <canvas id="heartChart"></canvas>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">‚ú¶</div>
          <h3>Luck Index (Quadrants)</h3>
        </div>
        <div class="chart-container">
          <canvas id="luckChart"></canvas>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üìä</div>
          <h3>Scoring Spread (Low/High)</h3>
        </div>
        <div class="chart-container">
          <canvas id="spreadChart"></canvas>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üìà</div>
          <h3>Career Trajectory</h3>
        </div>
        <div class="chart-container">
          <canvas id="careerChart"></canvas>
        </div>
      </div>

      <div class="card chart-card">
        <div class="chart-header">
          <div class="chart-icon">üèÅ</div>
          <h3>Post-Season Fate</h3>
        </div>
        <div class="chart-container" style="display:flex; flex-direction:column; justify-content:center;">
          <div id="fateFlow" class="fate-flow"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="table-wrap">
        <table id="seasonTable">
          <thead>
            <tr>
              <th>Year</th>
              <th>Record</th>
              <th>Finish</th>
              <th>Points For</th>
              <th>Points Against</th>
              <th>Seed</th>
              <th>Career Earnings</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

  </div>

  <script>
    // --- Constants & Global State ---
    let rawScores = [], rawStandings = [], rawSeeds = [];
    const charts = {};
    const leagueRatings = {};

    // Cached DOM
    const $ = (id) => document.getElementById(id);
    const els = {};

    // --- Helpers ---
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const safeNum = (v, fallback = 0) => Number.isFinite(Number(v)) ? Number(v) : fallback;
    const moneyFmt = (n) => `$${Number(n || 0).toLocaleString()}`;
    const keyMY = (m, y) => `${m}::${y}`;

    // League-wide latest year (used for tenure end detection)
    let latestLeagueYear = null;

    // Shrink very long names so they fit in two lines in the hero header.
    function fitHeroName() {
      const el = els.heroName;
      if (!el) return;
      // Reset to CSS-defined size first
      el.style.fontSize = '';
      el.style.lineHeight = '';
      const cs = window.getComputedStyle(el);
      const lineHeight = parseFloat(cs.lineHeight) || (parseFloat(cs.fontSize) * 1.1);
      const maxHeight = lineHeight * 2 + 1; // 2 lines (small buffer)
      // If it overflows, step font size down slightly until it fits (or hits a floor)
      let fs = parseFloat(cs.fontSize) || 32;
      const minFs = 20;
      while (el.scrollHeight > maxHeight && fs > minFs) {
        fs -= 1;
        el.style.fontSize = fs + 'px';
        el.style.lineHeight = '1.1';
      }
    }

    // NEW: Build tenure ranges (handles gaps like "2014-2019, 2022-Present")
    function formatTenureRanges(seasons) {
      const years = Array.from(new Set((seasons || []).map(s => safeNum(s.year, null)).filter(Number.isFinite))).sort((a,b)=>a-b);
      if (!years.length) return '‚Äî';

      const ranges = [];
      let start = years[0];
      let prev = years[0];

      for (let i = 1; i < years.length; i++) {
        const y = years[i];
        if (y === prev + 1) {
          prev = y;
          continue;
        }
        ranges.push([start, prev]);
        start = y;
        prev = y;
      }
      ranges.push([start, prev]);

      const parts = ranges.map(([a, b], idxRange) => {
        const isLast = idxRange === ranges.length - 1;
        if (a === b) {
          // single season segment
          return `${a}`;
        }
        if (isLast && Number.isFinite(latestLeagueYear) && b >= latestLeagueYear) {
          return `${a}-Present`;
        }
        return `${a}-${b}`;
      });

      return parts.join(', ');
    }

    // --- Dynamic Earnings Calculation ---
    function getEarnings(year, rank, hasScoringTitle, isFinalsApp) {
      let multiplier = 3.75; // Default (2021+)
      if (year <= 2017) multiplier = 1.0;
      else if (year <= 2019) multiplier = 2.0;
      else if (year === 2020) multiplier = 2.5;

      const baseSemis = 15 * multiplier;
      const baseFinalsApp = 20 * multiplier;
      const baseChamp = 120 * multiplier;
      const baseScoring = 20 * multiplier;

      let total = 0;

      if (rank <= 4) total += baseSemis;
      if (rank <= 2) total += baseFinalsApp;
      if (rank === 1) total += baseChamp;

      if (hasScoringTitle) total += baseScoring;

      return total;
    }

    function normalizeStandingsRow(s) {
      return {
        year: safeNum(s.year, null),
        manager: (s.manager ?? '').trim(),
        wins: safeNum(s.wins, 0),
        losses: safeNum(s.losses, 0),
        ties: safeNum(s.ties, 0),
        final_standing: safeNum((s.final_standing ?? s.finalStanding), null),
        division_finish: safeNum((s.division_finish ?? s.divisionFinish), null),
        points_for: safeNum((s.points_for ?? s.pointsFor), 0),
        points_against: safeNum((s.points_against ?? s.pointsAgainst), 0),
      };
    }

    function normalizeScoreRow(g) {
      return {
        year: safeNum(g.year, null),
        week: safeNum(g.week, null),
        manager1: (g.manager1 ?? '').trim(),
        manager2: (g.manager2 ?? '').trim(),
        score1: safeNum(g.score1, NaN),
        score2: safeNum(g.score2, NaN),
        playoffs: g.playoffs ?? "N/A"
      };
    }

    function calcStdDev(values) {
      if (!values.length) return 0;
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
      return Math.sqrt(variance);
    }

    // --- Indexes & Ranking Logic ---
    const idx = {
      managers: [],
      standingsByManager: new Map(),
      seedsByManagerYear: new Map(),
      gamesByManager: new Map(),
      weekBuckets: new Map(),
      scoringTitlesByManager: new Map(),
      seasonRanks: {}
    };

    function buildIndexes() {
      idx.managers = [];
      idx.standingsByManager.clear();
      idx.seedsByManagerYear.clear();
      idx.gamesByManager.clear();
      idx.weekBuckets.clear();
      idx.scoringTitlesByManager.clear();
      idx.seasonRanks = {};

      const managerSet = new Set();

      rawStandings.forEach(s => {
        if (!s.manager) return;
        managerSet.add(s.manager);
        if (!idx.standingsByManager.has(s.manager)) idx.standingsByManager.set(s.manager, []);
        idx.standingsByManager.get(s.manager).push(s);
      });
      idx.standingsByManager.forEach(arr => arr.sort((a, b) => b.year - a.year));

      rawSeeds.forEach(sd => {
        const m = (sd.manager ?? '').trim();
        const y = safeNum(sd.year, null);
        if (!m || !y) return;
        idx.seedsByManagerYear.set(keyMY(m, y), sd.seed);
        managerSet.add(m);
      });

      rawScores.forEach(row => {
        const g = normalizeScoreRow(row);
        if (!g.manager1 || !g.manager2) return;
        if (!Number.isFinite(g.score1) || !Number.isFinite(g.score2)) return;
        if (!Number.isFinite(g.year) || !Number.isFinite(g.week)) return;

        managerSet.add(g.manager1);
        managerSet.add(g.manager2);

        const bucketKey = `${g.year}::${g.week}`;
        if (!idx.weekBuckets.has(bucketKey)) idx.weekBuckets.set(bucketKey, []);
        idx.weekBuckets.get(bucketKey).push({ manager: g.manager1, score: g.score1, isPlayoff: (g.playoffs && g.playoffs !== "N/A") });
        idx.weekBuckets.get(bucketKey).push({ manager: g.manager2, score: g.score2, isPlayoff: (g.playoffs && g.playoffs !== "N/A") });

        const asGameFor = (name) => {
          const isAway = (g.manager1 === name);
          const myScore = isAway ? g.score1 : g.score2;
          const oppScore = isAway ? g.score2 : g.score1;
          const opponent = isAway ? g.manager2 : g.manager1;
          const result = myScore > oppScore ? 'W' : (myScore < oppScore ? 'L' : 'T');
          return {
            year: g.year,
            week: g.week,
            score: myScore,
            oppScore,
            opponent,
            result,
            isPlayoff: (g.playoffs && g.playoffs !== "N/A")
          };
        };

        [g.manager1, g.manager2].forEach(m => {
          if (!idx.gamesByManager.has(m)) idx.gamesByManager.set(m, []);
          idx.gamesByManager.get(m).push(asGameFor(m));
        });
      });

      idx.gamesByManager.forEach(arr => arr.sort((a, b) => (b.year !== a.year ? b.year - a.year : b.week - a.week)));
      idx.managers = Array.from(managerSet).sort((a, b) => a.localeCompare(b));

      const byYear = new Map();
      rawStandings.forEach(s => {
        if (!Number.isFinite(s.year) || !s.manager) return;
        if (!byYear.has(s.year)) byYear.set(s.year, []);
        byYear.get(s.year).push(s);
      });

      for (const [year, rows] of byYear.entries()) {
        rows.sort((a,b) => b.points_for - a.points_for);
        rows.forEach((r, i) => {
          const k = keyMY(r.manager, year);
          if(!idx.seasonRanks[k]) idx.seasonRanks[k] = {};
          idx.seasonRanks[k].pfRank = i + 1;
        });

        rows.sort((a,b) => b.points_against - a.points_against);
        rows.forEach((r, i) => {
          const k = keyMY(r.manager, year);
          if(!idx.seasonRanks[k]) idx.seasonRanks[k] = {};
          idx.seasonRanks[k].paRank = i + 1;
        });

        let maxPF = -Infinity;
        rows.forEach(r => { if (Number.isFinite(r.points_for)) maxPF = Math.max(maxPF, r.points_for); });
        if (Number.isFinite(maxPF) && maxPF > 0) {
          rows.forEach(r => {
            if (r.points_for === maxPF) {
              if (!idx.scoringTitlesByManager.has(r.manager)) idx.scoringTitlesByManager.set(r.manager, new Set());
              idx.scoringTitlesByManager.get(r.manager).add(year);
            }
          });
        }
      }
    }

    /***********************
     * Enhanced ELO helpers
     * (kept local + minimal; no UI changes)
     ***********************/
    function mean(arr) {
      if (!arr || !arr.length) return 0;
      return arr.reduce((a,b)=>a+b,0) / arr.length;
    }

    function stdev(arr) {
      if (!arr || arr.length < 2) return 0;
      const m = mean(arr);
      const v = mean(arr.map(x => (x - m) ** 2));
      return Math.sqrt(v);
    }

    function median(arr) {
      if (!arr || !arr.length) return 0;
      const s = [...arr].sort((a,b)=>a-b);
      const mid = Math.floor(s.length / 2);
      return (s.length % 2) ? s[mid] : (s[mid - 1] + s[mid]) / 2;
    }

    function bottomQuantileAverage(arr, q = 0.25) {
      if (!arr || !arr.length) return 0;
      const s = [...arr].sort((a,b)=>a-b);
      const k = Math.max(1, Math.floor(s.length * q));
      return mean(s.slice(0, k));
    }

    function eloExpected(rA, rB) {
      return 1 / (1 + Math.pow(10, (rB - rA) / 400));
    }

    function calculateAllRatings() {
      /**
       * Enhanced ELO (still looks/behaves like ELO on the page)
       * - Opponent strength (ELO core)
       * - Heavier playoffs
       * - Score quality (weekly z-score) + top-half credit via z-differential
       * - "Floor" focus: penalizes frequent/low dud weeks (bottom-quartile z), never penalizes 190s
       *
       * Implementation note:
       * - We keep updates zero-sum by applying one delta per matchup (A gains, B loses).
       * - Scoring quality enters as a small adjustment to the "result" via zA - zB (bounded).
       * - Floor enters via *expected win* (effective rating), so chronic dud teams are less "trusted."
       */

      const BASE = 1500;

      // Base K tuning (higher = more movement)
      const K_BASE = 40;
      const G0 = 30; // stabilizes after ~2+ seasons worth of games

      // Playoff weight (heavier)
      const PLAYOFF_MULT = 2.0;

      // Score-quality influence (weekly relative): affects effective result slightly
      const ETA_Z_DIFF = 0.08;      // 0.08 => small, noticeable; keep low for sanity
      const Z_DIFF_CAP = 0.15;      // max +/- added to result (so wins still matter most)

      // Floor / dud penalty (bottom-quartile z average): affects expected win only
      const FLOOR_LOOKBACK = 50;    // rolling window in games
      const FLOOR_Q = 0.25;         // worst 25%
      const FLOOR_FACTOR = 70;      // rating points per 1.0 z in floorAvg (negative lowers effective rating)
      const FLOOR_Z_CLIP = -2.5;    // avoid extreme early-season artifacts

      const rating = {};
      const gamesPlayed = {};
      const history = {};
      const zHist = {}; // manager -> array of weekly z-scores (for floor)

      // Initialize for every known manager
      idx.managers.forEach(m => {
        rating[m] = BASE;
        gamesPlayed[m] = 0;
        history[m] = [BASE];
        zHist[m] = [];
      });

      // Build chronologically ordered game list from league-scores.json
      const games = (rawScores || [])
        .map(normalizeScoreRow)
        .filter(g =>
          g.manager1 && g.manager2 &&
          Number.isFinite(g.score1) && Number.isFinite(g.score2) &&
          Number.isFinite(g.year) && Number.isFinite(g.week)
        )
        .sort((a, b) => (a.year !== b.year ? a.year - b.year : a.week - b.week));

      // Precompute per-week mean/std + top-half cutoff using idx.weekBuckets (already built from same rawScores)
      const weekStats = new Map(); // "year::week" -> { mu, sd, topCut }
      idx.weekBuckets.forEach((arr, key) => {
        const scores = (arr || []).map(x => safeNum(x.score, NaN)).filter(Number.isFinite);
        const mu = mean(scores);
        const sd = stdev(scores) || 1;
        const topCut = median(scores); // >= median => top half (simple, stable)
        weekStats.set(key, { mu, sd, topCut });
      });

      games.forEach(g => {
        const A = g.manager1;
        const B = g.manager2;

        // Ensure managers exist (in case a name appears only in scores)
        if (!(A in rating)) { rating[A] = BASE; gamesPlayed[A] = 0; history[A] = [BASE]; zHist[A] = []; }
        if (!(B in rating)) { rating[B] = BASE; gamesPlayed[B] = 0; history[B] = [BASE]; zHist[B] = []; }

        // Week stats for z-score
        const wkKey = `${g.year}::${g.week}`;
        const ws = weekStats.get(wkKey) || { mu: 0, sd: 1, topCut: Infinity };

        const zA = (g.score1 - ws.mu) / ws.sd;
        const zB = (g.score2 - ws.mu) / ws.sd;

        // Update z histories (used for floor, but floor is computed pre-update for this game)
        const zAHist = zHist[A] || [];
        const zBHist = zHist[B] || [];

        const floorAraw = bottomQuantileAverage(zAHist.slice(-FLOOR_LOOKBACK), FLOOR_Q);
        const floorBraw = bottomQuantileAverage(zBHist.slice(-FLOOR_LOOKBACK), FLOOR_Q);

        // Clip floor to avoid insane early/noisy values; note floors are typically <= 0
        const floorA = clamp(floorAraw, FLOOR_Z_CLIP, 0);
        const floorB = clamp(floorBraw, FLOOR_Z_CLIP, 0);

        // Effective ratings adjust expected win based on "how low your lows go"
        const RA = rating[A];
        const RB = rating[B];
        const effRA = RA + FLOOR_FACTOR * floorA; // floorA is negative => lowers effRA
        const effRB = RB + FLOOR_FACTOR * floorB;

        // Expected result (using effective ratings)
        const EA = eloExpected(effRA, effRB);

        // Actual result
        let SA = 0.5;
        if (g.score1 > g.score2) SA = 1;
        else if (g.score1 < g.score2) SA = 0;

        // Score-quality adjustment to the result (bounded), based on weekly-relative performance
        const zDiff = zA - zB;
        const adj = clamp(ETA_Z_DIFF * zDiff, -Z_DIFF_CAP, Z_DIFF_CAP);
        const SA_adj = clamp(SA + adj, 0, 1);

        // Margin of victory multiplier (keep your existing behavior, but prevent extreme spikes)
        const m = Math.abs(g.score1 - g.score2);
        const M = clamp(Math.log(m + 1), 0.2, 2.2);

        // Playoff weighting (heavier)
        const isPlayoff = (g.playoffs && g.playoffs !== "N/A") ? 1 : 0;
        const P = isPlayoff ? PLAYOFF_MULT : 1.0;

        // K-factor with sample-size stabilization (average to keep updates symmetric)
        const KA = K_BASE * (G0 / (G0 + (gamesPlayed[A] || 0)));
        const KB = K_BASE * (G0 / (G0 + (gamesPlayed[B] || 0)));
        const K = (KA + KB) / 2;

        const delta = (K * P * M) * (SA_adj - EA);

        rating[A] = RA + delta;
        rating[B] = RB - delta;

        gamesPlayed[A] = (gamesPlayed[A] || 0) + 1;
        gamesPlayed[B] = (gamesPlayed[B] || 0) + 1;

        history[A].push(rating[A]);
        history[B].push(rating[B]);

        // Now append z-scores (after using prior history for floor)
        zAHist.push(zA);
        zBHist.push(zB);
        zHist[A] = zAHist;
        zHist[B] = zBHist;
      });

      // Compute ranks (1 = highest Elo)
      // --- Rank only managers with 3+ seasons ---
      const MIN_SEASONS_FOR_RANK = 3;
      
      // Count distinct seasons per manager
      const seasonCounts = {};
      rawStandings.forEach(s => {
        if (!s.manager || !Number.isFinite(s.year)) return;
        if (!seasonCounts[s.manager]) seasonCounts[s.manager] = new Set();
        seasonCounts[s.manager].add(s.year);
      });
      
      // Eligible managers = 3+ seasons
      const eligibleManagers = Object.keys(rating).filter(m => {
        return (seasonCounts[m]?.size || 0) >= MIN_SEASONS_FOR_RANK;
      });
      
      // Sort ONLY eligible managers by Elo
      eligibleManagers.sort((a, b) => rating[b] - rating[a]);
      
      // Assign ranks within eligible pool
      const rankMap = {};
      eligibleManagers.forEach((m, i) => {
        rankMap[m] = i + 1;
      });
      
      // Everyone else gets no rank
      Object.keys(rating).forEach(m => {
        if (!(m in rankMap)) rankMap[m] = null;
      });

      managers.forEach(m => {
        const h = history[m] || [BASE];
        const peak = Math.max(...h);
        const floor = Math.min(...h);

        const last = h[h.length - 1];
        const prev10 = h.length > 10 ? h[h.length - 11] : h[0];
        const d10 = last - prev10;

        leagueRatings[m] = {
          elo: Math.round(last),
          peak: Math.round(peak),
          floor: Math.round(floor),
          d10: Math.round(d10),
          rank: rankMap[m] || '-'
        };
      });
    }

    function initManagerDropdown() {
      const select = els.managerSelect;
      select.innerHTML = '';
      idx.managers.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        select.appendChild(opt);
      });
      select.addEventListener('change', (e) => loadManager(e.target.value));
    }

    function loadManager(name) {
      const mySeasons = idx.standingsByManager.get(name) || [];
      const myGames = idx.gamesByManager.get(name) || [];

      const h2h = {};
      myGames.forEach(g => {
        if (!g.opponent) return;
        if (!h2h[g.opponent]) h2h[g.opponent] = { w: 0, l: 0, t: 0, games: 0 };
        h2h[g.opponent].games++;
        if (g.result === 'W') h2h[g.opponent].w++;
        else if (g.result === 'L') h2h[g.opponent].l++;
        else h2h[g.opponent].t++;
      });

      renderHero(name, mySeasons);
      renderStats(mySeasons, myGames, name);
      renderRivalries(h2h);
      renderSeasonTable(mySeasons, name);
      renderLuckChart(mySeasons, name);
      renderSpreadChart(myGames);
      renderClutchChart(myGames);
      renderCareerChart(mySeasons);
      renderFormStrip(myGames);

      renderHardwareChart(mySeasons);
      renderHeartAttackChart(myGames);
      renderHighLow(myGames);
      renderFateFlow(mySeasons, name);
    }

function renderHero(name, seasons) {
  const initials = name.split(' ').filter(Boolean).map(n => n[0]).join('').substring(0, 2).toUpperCase();
  els.heroAvatar.textContent = initials;
  els.heroName.textContent = name;
  fitHeroName();
  els.heroTenure.textContent = formatTenureRanges(seasons);

  const caseEl = els.trophyCase;
  caseEl.innerHTML = '';

  // --- Hardware counts ---
  let champs = 0, runners = 0, thirds = 0, divisions = 0;
  seasons.forEach(s => {
    if (s.final_standing === 1) champs++;
    else if (s.final_standing === 2) runners++;
    else if (s.final_standing === 3) thirds++;
    if (s.division_finish === 1) divisions++;
  });

  const scoringTitles =
    idx.scoringTitlesByManager.get(name)?.size || 0;

  const pills = [];

  if (champs > 0)
    pills.push(`<span class="trophy-badge gold">üèÜ Champion √ó${champs}</span>`);
  if (runners > 0)
    pills.push(`<span class="trophy-badge silver">ü•à Runner-Up √ó${runners}</span>`);
  if (thirds > 0)
    pills.push(`<span class="trophy-badge bronze">ü•â 3rd Place √ó${thirds}</span>`);
  if (scoringTitles > 0)
    pills.push(`<span class="trophy-badge scoring">üïπÔ∏è Scoring Title √ó${scoringTitles}</span>`);
  if (divisions > 0)
    pills.push(
      `<span class="trophy-badge" style="
        background: rgba(34,197,94,0.15);
        border-color: rgba(34,197,94,0.4);
        color: var(--positive);
      ">üèÅ Division Title √ó${divisions}</span>`
    );

  caseEl.innerHTML = pills.length
    ? pills.join('')
    : `<span class="empty-case">No hardware... yet.</span>`;

  const r = leagueRatings[name];
  const ovrEl = els.heroOvr;
  const target = r.elo;
  let current = clamp(Number(ovrEl.textContent) || 0, 0, target);

  const step = () => {
    current = Math.min(target, current + Math.max(1, Math.ceil(target / 40)));
    ovrEl.textContent = current;
    if (current < target) requestAnimationFrame(step);
    };
  step();

  els.ratingSCOR.textContent = r.peak;
  els.ratingGM.textContent = r.floor;
  els.ratingCLT.textContent = (r.d10 >= 0 ? "+" : "") + r.d10;
  els.ratingSTB.textContent = r.rank ?? '‚Äî';
  }

    function renderStats(seasons, games, managerName) {
      const w = games.filter(g => g.result === 'W').length;
      const l = games.filter(g => g.result === 'L').length;
      const t = games.filter(g => g.result === 'T').length;

      els.statRecord.textContent = `${w}-${l}-${t}`;

      const pct = games.length ? (w + t * 0.5) / games.length : 0;
      els.statWinPct.textContent = pct.toFixed(3);

      const finishes = seasons.map(s => s.final_standing).filter(Number.isFinite);
      const avgFin = finishes.length ? finishes.reduce((a, b) => a + b, 0) / finishes.length : 0;
      els.statAvgFinish.textContent = avgFin > 0 ? avgFin.toFixed(1) : '-';

      const totalScore = games.reduce((a, g) => a + g.score, 0);
      const avgScore = games.length ? totalScore / games.length : 0;
      els.statAvgScore.textContent = avgScore.toFixed(1);

      let money = 0;
      seasons.forEach(s => {
        const hasScoring = (idx.scoringTitlesByManager.get(managerName) || new Set()).has(s.year);
        money += getEarnings(s.year, s.final_standing, hasScoring);
      });
      els.statEarnings.textContent = moneyFmt(money);
      els.statEarnings.style.color = 'var(--money)';
    }

    function renderRivalries(h2h) {
      let nemesis = { name: '-', pct: 1.0, rec: '' };
      let pigeon = { name: '-', pct: 0.0, rec: '' };

      Object.keys(h2h).forEach(opp => {
        const d = h2h[opp];
        if (d.games < 5) return;
        const pct = (d.w + d.t * 0.5) / d.games;
        if (pct <= nemesis.pct) nemesis = { name: opp, pct, rec: `${d.w}-${d.l}` };
        if (pct >= pigeon.pct) pigeon = { name: opp, pct, rec: `${d.w}-${d.l}` };
      });

      els.nemesisName.textContent = nemesis.name;
      els.nemesisStat.textContent = nemesis.rec || '-';
      els.pigeonName.textContent = pigeon.name;
      els.pigeonStat.textContent = pigeon.rec || '-';
    }

    function renderSeasonTable(seasons, managerName) {
      const tbody = document.querySelector('#seasonTable tbody');
      tbody.innerHTML = '';
      const frag = document.createDocumentFragment();

      seasons.forEach(s => {
        const seed = idx.seedsByManagerYear.get(keyMY(managerName, s.year)) ?? '-';
        const rank = s.final_standing;

        const hasScoring = (idx.scoringTitlesByManager.get(managerName) || new Set()).has(s.year);
        const money = getEarnings(s.year, rank, hasScoring);

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${s.year ?? '-'}</td>
          <td>${s.wins}-${s.losses}-${s.ties}</td>
          <td>${Number.isFinite(rank) ? rank : '-'}</td>
          <td>${Math.round(s.points_for || 0).toLocaleString()}</td>
          <td>${Math.round(s.points_against || 0).toLocaleString()}</td>
          <td>${seed}</td>
          <td style="color:${money > 0 ? 'var(--money)' : 'inherit'}">${money > 0 ? moneyFmt(money) : '-'}</td>
        `;
        frag.appendChild(tr);
      });

      tbody.appendChild(frag);
    }

    function renderFormStrip(games) {
      const strip = els.formStrip;
      const recEl = els.formRecord;
      if (!strip || !recEl) return;
      strip.innerHTML = '';

      const last10 = [...games]
        .filter(g => Number.isFinite(g.year) && Number.isFinite(g.week))
        .sort((a, b) => (a.year !== b.year ? b.year - a.year : b.week - a.week))
        .slice(0, 10);

      let w = 0, l = 0, t = 0;
      last10.forEach(g => {
        if (g.result === 'W') w++;
        else if (g.result === 'L') l++;
        else t++;

        const dot = document.createElement('div');
        dot.className = 'form-dot';
        dot.dataset.res = g.result;
        dot.tabIndex = 0;

        const opp = g.opponent || '?';
        const score = Number.isFinite(g.score) ? g.score.toFixed(1) : '';
        const oppScore = Number.isFinite(g.oppScore) ? g.oppScore.toFixed(1) : '';
        dot.dataset.tooltip = `${g.year} Wk ${g.week}: ${g.result} vs ${opp} (${score}‚Äì${oppScore})`;

        strip.appendChild(dot);
      });

      recEl.textContent = last10.length ? `${w}-${l}-${t}` : '‚Äî';
    }

    function renderHighLow(games) {
      const el = $('hlTicker');
      if(!el) return;

      const validGames = games.filter(g => Number.isFinite(g.score));
      if(!validGames.length) { el.innerHTML = ''; return; }

      validGames.sort((a,b) => b.score - a.score);
      const high = validGames[0];
      const low = validGames[validGames.length - 1];

      el.innerHTML = `
        <div class="hl-row hl-high">
          <div class="hl-icon">‚ñ≤</div>
          <div class="hl-data">
            <div class="hl-score">${high.score.toFixed(2)}</div>
            <div class="hl-meta">${high.year} Wk ${high.week} vs ${high.opponent}</div>
          </div>
        </div>
        <div class="hl-row hl-low">
          <div class="hl-icon">‚ñº</div>
          <div class="hl-data">
            <div class="hl-score">${low.score.toFixed(2)}</div>
            <div class="hl-meta">${low.year} Wk ${low.week} vs ${low.opponent}</div>
          </div>
        </div>
      `;
    }

    function renderFateFlow(seasons, managerName) {
      const container = $('fateFlow');
      if(!container) return;

      let total = 0, playoffs = 0, finals = 0, titles = 0;

      seasons.forEach(s => {
        if(!Number.isFinite(s.year)) return;
        total++;
        const seed = idx.seedsByManagerYear.get(keyMY(managerName, s.year));
        const rank = s.final_standing;

        let madePlayoffs = false;
        if(seed) madePlayoffs = true;
        if(Number.isFinite(rank) && rank <= 6) madePlayoffs = true;

        if(madePlayoffs) playoffs++;
        if(Number.isFinite(rank)) {
          if(rank <= 2) finals++;
          if(rank === 1) titles++;
        }
      });

      const pctP = total ? (playoffs / total * 100) : 0;
      const pctF = total ? (finals / total * 100) : 0;
      const pctT = total ? (titles / total * 100) : 0;

      container.innerHTML = `
        <div class="fate-step">
          <div class="fate-bar" style="width:100%"></div>
          <div class="fate-label">Seasons Played</div>
          <div class="fate-val">${total}</div>
        </div>
        <div class="fate-step step-playoffs">
          <div class="fate-bar" style="width:${pctP}%"></div>
          <div class="fate-label">Made Playoffs</div>
          <div class="fate-val">${playoffs}</div>
        </div>
        <div class="fate-step step-finals">
          <div class="fate-bar" style="width:${pctF}%"></div>
          <div class="fate-label">Made Finals</div>
          <div class="fate-val">${finals}</div>
        </div>
        <div class="fate-step step-titles">
          <div class="fate-bar" style="width:${pctT}%"></div>
          <div class="fate-label">Champion</div>
          <div class="fate-val">${titles}</div>
        </div>
      `;
    }

    // --- Charts ---
    Chart.defaults.color = '#64748b';
    Chart.defaults.font.family = 'system-ui';
    const commonOptions = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } } };

    function renderLuckChart(seasons, managerName) {
      const canvas = $('luckChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.luck) charts.luck.destroy();

      const points = seasons.map(s => {
        const k = keyMY(managerName, s.year);
        const ranks = idx.seasonRanks[k] || { pfRank: 6, paRank: 6 };
        return { x: ranks.pfRank, y: ranks.paRank, year: s.year };
      });

      const quadrantPlugin = {
        id: 'quadrants',
        beforeDraw(chart) {
          const { ctx, chartArea: { top, bottom, left, right } } = chart;
          const midX = (left + right) / 2;
          const midY = (top + bottom) / 2;
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(midX, top); ctx.lineTo(midX, bottom);
          ctx.moveTo(left, midY); ctx.lineTo(right, midY);
          ctx.stroke();
          ctx.font = '600 9px system-ui';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.textAlign = 'center';

          ctx.fillText("DOMINANT & LUCKY", (left + midX) / 2, top + 15);
          ctx.fillText("SUBPAR & LUCKY", (midX + right) / 2, top + 15);
          ctx.fillText("DOMINANT & UNLUCKY", (left + midX) / 2, bottom - 10);
          ctx.fillText("SUBPAR & UNLUCKY", (midX + right) / 2, bottom - 10);

          ctx.restore();
        }
      };

      charts.luck = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            data: points,
            backgroundColor: 'rgba(56, 189, 248, 0.55)',
            borderColor: 'rgba(56, 189, 248, 0.9)',
            pointBorderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8
          }]
        },
        plugins: [quadrantPlugin],
        options: {
          ...commonOptions,
          layout: { padding: { top: 10 } },
          scales: {
            x: {
              title: { display: true, text: 'PF Rank (1=Best)' },
              min: 0,
              max: 12,
              ticks: { stepSize: 1, callback: (v) => Number(v).toFixed(0) },
              grid: { display: false },
              reverse: false
            },
            y: {
              title: { display: true, text: 'PA Rank (1=Unlucky)' },
              min: 0,
              max: 12,
              ticks: { stepSize: 1, callback: (v) => Number(v).toFixed(0) },
              grid: { display: false },
              reverse: false
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: { callbacks: { label: (c) => `${c.raw.year}: PF #${c.raw.x} | PA #${c.raw.y}` } }
          }
        }
      });
    }

    function renderSpreadChart(games) {
      const canvas = $('spreadChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.spread) charts.spread.destroy();

      const years = [...new Set(games.map(g => g.year).filter(Number.isFinite))].sort((a, b) => a - b);
      const data = years.map(y => {
        const scores = games.filter(g => g.year === y).map(g => g.score).filter(Number.isFinite);
        if (!scores.length) return [0, 0];
        return [Math.min(...scores), Math.max(...scores)];
      });

      charts.spread = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: data,
            backgroundColor: 'rgba(56, 189, 248, 0.4)',
            borderWidth: 0,
            borderSkipped: false,
            borderRadius: 4,
            barPercentage: 0.6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: { callbacks: { label: (c) => `Range: ${c.raw[0]} - ${c.raw[1]}` } }
          },
          scales: { y: { grid: { color: 'rgba(255,255,255,0.05)' } }, x: { grid: { display: false } } }
        }
      });
    }

    function renderClutchChart(games) {
      const canvas = $('clutchChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.clutch) charts.clutch.destroy();

      const reg = games.filter(g => !g.isPlayoff).map(g => g.score).filter(Number.isFinite);
      const play = games.filter(g => g.isPlayoff).map(g => g.score).filter(Number.isFinite);

      const regAvg = reg.length ? reg.reduce((a, b) => a + b, 0) / reg.length : 0;
      const playAvg = play.length ? play.reduce((a, b) => a + b, 0) / play.length : 0;

      charts.clutch = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Regular Season', 'Playoffs'],
          datasets: [{ data: [regAvg, playAvg], backgroundColor: ['#38bdf8', '#fbbf24'], borderRadius: 4 }]
        },
        options: {
          ...commonOptions,
          indexAxis: 'y',
          scales: {
            x: { grid: { display: false }, ticks: { color: '#94a3b8' } },
            y: { grid: { display: false }, ticks: { color: '#fff', font: { weight: 'bold' } } }
          }
        }
      });
    }

    function renderCareerChart(seasons) {
      const canvas = $('careerChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.career) charts.career.destroy();

      const sorted = [...seasons].filter(s => Number.isFinite(s.year)).sort((a, b) => a.year - b.year);

      charts.career = new Chart(ctx, {
        type: 'line',
        data: {
          labels: sorted.map(s => s.year),
          datasets: [{
            data: sorted.map(s => Number.isFinite(s.final_standing) ? s.final_standing : null),
            borderColor: '#38bdf8',
            borderWidth: 2,
            tension: 0.3,
            fill: false,
            pointBackgroundColor: '#0f172a',
            pointBorderColor: '#38bdf8',
            pointBorderWidth: 2
          }]
        },
        options: {
          ...commonOptions,
          layout: { padding: { top: 16, bottom: 16 } },
          scales: {
            y: {
              reverse: false,
              min: 1,
              max: 12,
              grace: '10%',
              ticks: { stepSize: 1, callback: (v) => Number(v).toFixed(0) },
              grid: { color: 'rgba(255,255,255,0.05)' }
            },
            x: { grid: { display: false } }
          }
        }
      });
    }

    function renderHeartAttackChart(games) {
      const canvas = $('heartChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.heart) charts.heart.destroy();

      let wins=0, losses=0;
      games.forEach(g => {
        if(Number.isFinite(g.score) && Number.isFinite(g.oppScore)) {
          const diff = Math.abs(g.score - g.oppScore);
          if(diff < 5) {
            if(g.result === 'W') wins++;
            else if(g.result === 'L') losses++;
          }
        }
      });

      charts.heart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: ['Wins', 'Losses'],
          datasets: [{
            data: [wins, losses],
            backgroundColor: ['#22c55e', '#ef4444'],
            borderWidth: 0,
            hoverOffset: 4
          }]
        },
        options: {
          ...commonOptions,
          cutout: '65%',
          plugins: {
            legend: { display: true, position: 'bottom', labels: { color: '#94a3b8' } }
          }
        }
      });
    }

    function renderHardwareChart(seasons) {
      const canvas = $('hardwareChart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (charts.hw) charts.hw.destroy();

      let g=0, s=0, b=0, none=0;
      seasons.forEach(row => {
        const r = row.final_standing;
        if(r === 1) g++;
        else if(r === 2) s++;
        else if(r === 3) b++;
        else none++;
      });

      charts.hw = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Career Finishes'],
          datasets: [
            { label: 'Gold', data: [g], backgroundColor: '#fbbf24', barThickness: 40 },
            { label: 'Silver', data: [s], backgroundColor: '#cbd5e1', barThickness: 40 },
            { label: 'Bronze', data: [b], backgroundColor: '#d97706', barThickness: 40 },
            { label: 'Other', data: [none], backgroundColor: '#334155', barThickness: 40 }
          ]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: true, position: 'bottom', labels: { color:'#94a3b8' } } },
          scales: {
            x: { stacked: true, grid: { display:false }, ticks:{ color:'#94a3b8', stepSize:1 } },
            y: { stacked: true, display: false }
          }
        }
      });
    }

    function showErrorCard(msg) {
      const shell = document.querySelector('.shell');
      if (!shell) return;
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `<div style="color:var(--text-main); font-weight:700;">${msg}</div>`;
      shell.appendChild(div);
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', async () => {
      window.addEventListener('resize', () => { try { fitHeroName(); } catch(e){} });

      [
        'managerSelect', 'heroAvatar', 'heroName', 'heroTenure', 'trophyCase', 'heroOvr',
        'ratingSCOR', 'ratingGM', 'ratingCLT', 'ratingSTB',
        'statRecord', 'statWinPct', 'statAvgFinish', 'statAvgScore', 'statEarnings',
        'nemesisName', 'nemesisStat', 'pigeonName', 'pigeonStat',
        'formStrip', 'formRecord'
      ].forEach(id => els[id] = $(id));

      try {
        const [sRes, stRes, sdRes] = await Promise.all([
          fetch('league-scores.json'),
          fetch('final-standings.json'),
          fetch('playoff-seeds.json')
        ]);

        if (!sRes.ok || !stRes.ok || !sdRes.ok) {
          throw new Error(`Data load failed: scores=${sRes.status}, standings=${stRes.status}, seeds=${sdRes.status}`);
        }

        rawScores = (await sRes.json()) || [];
        rawStandings = ((await stRes.json()) || []).map(normalizeStandingsRow);
        rawSeeds = (await sdRes.json()) || [];

        const allYears = rawStandings.map(r => r.year).filter(Number.isFinite);
        latestLeagueYear = allYears.length ? Math.max(...allYears) : null;

        buildIndexes();
        calculateAllRatings();
        initManagerDropdown();

        const firstMgr = els.managerSelect.options?.[0]?.value;
        if (firstMgr) loadManager(firstMgr);
        else showErrorCard("No managers found in your data files.");

      } catch (err) {
        console.error(err);
        showErrorCard("Unable to load league data. Please ensure JSON files are present and valid.");
      }
    });
  </script>
</body>
</html>
