<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="style.css">
  <meta charset="UTF-8">
  <meta name="robots" content="noindex, nofollow">
  <title>Draft Analytics – LWFFL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg-main: #020617;
      --card-bg: #020617;
      --accent: #38bdf8;
      --border-subtle: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;
      --positive: #22c55e;
      --warning: #f59e0b;
      --negative: #ef4444;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 35%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 24px 16px;
    }
    .shell { max-width: 1240px; margin: 24px auto; }
    .container {
      background: radial-gradient(circle at top left, rgba(56,189,248,0.12), transparent 55%), radial-gradient(circle at bottom right, rgba(59,130,246,0.18), transparent 55%), var(--card-bg);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.3);
      box-shadow: 0 40px 80px rgba(0,0,0,0.8), 0 0 0 1px rgba(15,23,42,0.9);
      padding: 28px 22px;
      backdrop-filter: blur(14px);
    }
    .header { text-align: center; margin-bottom: 20px; }
    .header h1 { font-size: 1.9rem; letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 8px; }
    .header p { color: var(--text-soft); font-size: 0.86rem; letter-spacing: 0.08em; text-transform: uppercase; }

    .controls {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 12px;
      margin-bottom: 18px;
      background: rgba(30,41,59,0.4);
      padding: 14px;
      border-radius: 12px;
      border: 1px solid rgba(55,65,81,0.5);
    }
    label { display: block; margin-bottom: 6px; color: var(--text-muted); font-weight: 600; font-size: 0.72rem; letter-spacing: 0.1em; text-transform: uppercase; }
    select {
      width: 100%; padding: 9px 11px; background-color: #0b1120; border: 1px solid rgba(75,85,99,0.8);
      border-radius: 8px; color: #f9fafb; font-size: 0.92rem; appearance: none; cursor: pointer;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2338bdf8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat; background-position: right 0.8rem center; background-size: 0.9em;
    }
    select[multiple] {
      appearance: auto;
      background-image: none;
      min-height: 108px;
      padding: 8px;
    }

    .cards-grid { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 10px; margin-bottom: 16px; }
    .stat-card {
      border: 1px solid rgba(55,65,81,0.6); border-radius: 12px; padding: 12px;
      background: linear-gradient(160deg, rgba(56,189,248,0.12), rgba(15,23,42,0.92));
      min-height: 96px;
    }
    .stat-label { color: var(--text-muted); font-size: 0.66rem; letter-spacing: 0.08em; text-transform: uppercase; }
    .stat-value { margin-top: 6px; font-size: 1.1rem; font-weight: 700; line-height: 1.2; }
    .stat-note { margin-top: 6px; font-size: 0.75rem; color: var(--text-soft); }

    .panel { background: radial-gradient(circle at top, rgba(15,23,42,0.9), rgba(2,6,23,0.95)); border: 1px solid rgba(55,65,81,0.6); border-radius: 14px; padding: 18px; margin-bottom: 16px; }
    .panel h2 { font-size: 0.9rem; letter-spacing: 0.1em; text-transform: uppercase; color: var(--text-muted); margin-bottom: 10px; }
    .subtle { color: var(--text-soft); font-size: 0.8rem; margin-bottom: 12px; }
    .table-wrap { width: 100%; overflow-x: auto; border-radius: 8px; border: 1px solid rgba(55,65,81,0.5); }
    table { width: 100%; border-collapse: collapse; min-width: 900px; font-size: 0.86rem; }
    th, td { text-align: left; padding: 10px 12px; border-bottom: 1px solid rgba(55,65,81,0.3); }
    th { background: rgba(30,41,59,0.7); color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.08em; font-size: 0.69rem; }
    th.sortable { cursor: pointer; user-select: none; }
    th.sortable::after { content: ' ↕'; color: var(--text-soft); font-size: 0.75em; }
    th.sortable[data-sort-dir='asc']::after { content: ' ↑'; color: var(--accent); }
    th.sortable[data-sort-dir='desc']::after { content: ' ↓'; color: var(--accent); }
    tbody tr:hover { background: rgba(56,189,248,0.05); }

    th[data-tooltip] { position: relative; }
    th[data-tooltip]:hover::before,
    th[data-tooltip]:focus-visible::before {
      content: attr(data-tooltip);
      position: absolute;
      left: 0;
      top: calc(100% + 8px);
      z-index: 20;
      width: min(320px, 78vw);
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(56,189,248,0.5);
      background: rgba(2,6,23,0.96);
      color: var(--text-main);
      font-size: 0.73rem;
      line-height: 1.35;
      text-transform: none;
      letter-spacing: normal;
      white-space: normal;
      box-shadow: 0 8px 24px rgba(0,0,0,0.45);
      pointer-events: none;
    }
    .ratio-good { color: var(--positive); font-weight: 700; }
    .ratio-mid { color: var(--warning); font-weight: 700; }
    .ratio-bad { color: var(--negative); font-weight: 700; }
    .status { color: var(--text-soft); margin-bottom: 12px; font-size: 0.86rem; }

    .insight-list { margin: 6px 0 0 18px; color: var(--text-main); }
    .insight-list li { margin-bottom: 8px; line-height: 1.4; }
    .insight-list li:last-child { margin-bottom: 0; }
    details.explainer {
      border: 1px solid rgba(56,189,248,0.35);
      background: rgba(15,23,42,0.55);
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 10px;
    }
    details.explainer summary {
      cursor: pointer;
      color: var(--accent);
      font-size: 0.8rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
      margin-bottom: 8px;
    }
    details.explainer[open] summary { margin-bottom: 10px; }
    @media (max-width: 960px) { .cards-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } .controls { grid-template-columns: 1fr; } }
    @media (max-width: 640px) { .cards-grid { grid-template-columns: 1fr; } .header h1 { font-size: 1.6rem; } }
  </style>
</head>
<body>
  <div id="nav-placeholder"></div>

  <div class="shell">
    <div class="container">
      <div class="header">
        <h1>Draft Analytics</h1>
        <p>Manager tendencies, value outcomes, and draft value scores over time</p>
      </div>

      <div class="controls">
        <div>
          <label for="managerSelect">Manager</label>
          <select id="managerSelect" multiple></select>
        </div>
        <div>
          <label for="yearSelect">Year</label>
          <select id="yearSelect" multiple></select>
        </div>
        <div>
          <label for="positionSelect">Position</label>
          <select id="positionSelect" multiple></select>
        </div>
        <div>
          <label for="roundCostSelect">Round / Cost (Draft-Context Round Equivalent)</label>
          <select id="roundCostSelect" multiple></select>
        </div>
      </div>

      <div id="status" class="status">Loading draft analytics...</div>

      <section class="cards-grid" data-detail-level="core">
        <article class="stat-card"><div class="stat-label">Best Value Pick</div><div id="bestValuePick" class="stat-value">-</div><div id="bestValuePickNote" class="stat-note"></div></article>
        <article class="stat-card"><div class="stat-label">Average Value Score</div><div id="avgScore" class="stat-value">-</div><div class="stat-note">ln(positional draft slot ÷ finish rank)</div></article>
        <article class="stat-card"><div class="stat-label">Strong Picks</div><div id="strongPickRate" class="stat-value">-</div><div class="stat-note">Share of picks with positive value score</div></article>
        <article class="stat-card"><div class="stat-label">Qualified Picks</div><div id="qualifiedPicks" class="stat-value">-</div><div class="stat-note">Picks with a known finish rank</div></article>
      </section>

      <section class="panel">
        <h2>Manager Leaderboard</h2>
        <p class="subtle">Managers ranked by beat-cost rate, avg percentile gain, and filtered risk control.</p>
        <div class="table-wrap">
          <table data-sort-table="managerLeaderboard">
            <thead>
              <tr>
                <th class="sortable" data-sort-key="rank">Rank</th>
                <th class="sortable" data-sort-key="manager">Manager</th>
                <th class="sortable" data-sort-key="beatCostRate">Beat Cost Rate</th>
                <th class="sortable" data-sort-key="avgPercentileDelta">Avg Percentile Δ</th>
                <th class="sortable" data-sort-key="bestPosition">Best Position</th>
                <th class="sortable" data-sort-key="safetyRate">Safety Rate</th>
                <th class="sortable" data-sort-key="bustRate">Bust Rate</th>
                <th class="sortable" data-sort-key="eligiblePicks">Eligible Picks</th>
              </tr>
            </thead>
            <tbody id="managerLeaderboardBody"></tbody>
          </table>
        </div>
      </section>

      <section class="panel">
        <h2>Year Comparison</h2>
        <p class="subtle">Compare draft classes by value hits, busts, and positional trend strength.</p>
        <div class="table-wrap">
          <table data-sort-table="yearComparison">
            <thead>
              <tr>
                <th class="sortable" data-sort-key="year">Year</th>
                <th class="sortable" data-sort-key="hits">Value Hits</th>
                <th class="sortable" data-sort-key="busts">Busts</th>
                <th class="sortable" data-sort-key="hitRate">Hit Rate</th>
                <th class="sortable" data-sort-key="bustRate">Bust Rate</th>
                <th class="sortable" data-sort-key="topPosScore">Top Position Trend</th>
              </tr>
            </thead>
            <tbody id="yearComparisonBody"></tbody>
          </table>
        </div>
      </section>

      <section class="panel">
        <h2>Position Breakdown</h2>
        <p class="subtle">How efficiently each position was drafted in the filtered sample (higher score is better).</p>
        <div class="table-wrap">
          <table data-sort-table="positionBreakdown">
            <thead>
              <tr>
                <th class="sortable" data-sort-key="position">Position</th>
                <th class="sortable" data-sort-key="picks">Picks</th>
                <th class="sortable" data-sort-key="avgScore">Avg Score</th>
                <th class="sortable" data-sort-key="medianScore">Median Score</th>
                <th class="sortable" data-sort-key="strongRate">Strong Picks</th>
              </tr>
            </thead>
            <tbody id="positionBreakdownBody"></tbody>
          </table>
        </div>
      </section>

      <section class="panel">
        <h2>Best Value Picks in Current Filter</h2>
        <p class="subtle">Top value picks by value score for the currently selected manager, year, and position filters.</p>
        <div class="table-wrap">
          <table data-sort-table="auctionBargains">
            <thead>
              <tr>
                <th class="sortable" data-sort-key="year">Year</th>
                <th class="sortable" data-sort-key="name">Player</th>
                <th class="sortable" data-sort-key="manager">Manager</th>
                <th class="sortable" data-sort-key="position">Pos</th>
                <th class="sortable" data-sort-key="draftType">Draft Type</th>
                <th class="sortable" data-sort-key="acquisitionCost">Acquisition Cost</th>
                <th class="sortable" data-sort-key="finishRank">Finish Rank</th>
                <th class="sortable" data-sort-key="valueScore">Value Score</th>
              </tr>
            </thead>
            <tbody id="auctionBargainBody"></tbody>
          </table>
        </div>
      </section>
    </div>
  </div>

  <script src="nav-loader.js"></script>
  <script type="module">
    import { enrichDraftEntries, summarizeByManager, summarizeByYear } from './draft-metrics.mjs';

    const state = {
      rows: [],
      manager: [],
      year: [],
      position: [],
      roundCost: [],
      sorts: {
        managerLeaderboard: { key: 'beatCostRate', dir: 'desc' },
        yearComparison: { key: 'year', dir: 'desc' },
        positionBreakdown: { key: 'position', dir: 'asc' },
        auctionBargains: { key: 'valueScore', dir: 'desc' }
      }
    };

    const managerSelect = document.getElementById('managerSelect');
    const yearSelect = document.getElementById('yearSelect');
    const positionSelect = document.getElementById('positionSelect');
    const roundCostSelect = document.getElementById('roundCostSelect');
    const statusEl = document.getElementById('status');
    const ALL_OPTION_VALUE = '__ALL__';

    function average(values) {
      if (!values.length) return null;
      return values.reduce((a, b) => a + b, 0) / values.length;
    }

    function median(values) {
      if (!values.length) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }


    function scoreClass(score) {
      if (score == null) return '';
      if (score > 0.15) return 'ratio-good';
      if (score >= -0.15) return 'ratio-mid';
      return 'ratio-bad';
    }

    function valueToHeatColor(value, min, max) {
      if (value == null || min == null || max == null) return '';
      if (max === min) return 'hsl(60 85% 52%)';
      const ratio = Math.max(0, Math.min(1, (value - min) / (max - min)));
      const hue = ratio * 120;
      return `hsl(${hue} 85% 52%)`;
    }

    function minMax(values) {
      if (!values.length) return { min: null, max: null };
      return {
        min: Math.min(...values),
        max: Math.max(...values)
      };
    }

    function formatScore(score, digits = 2) {
      return score == null ? '—' : score.toFixed(digits);
    }

    function formatPct(value) {
      return value == null ? '—' : `${(value * 100).toFixed(1)}%`;
    }

    function compareValues(a, b) {
      if (a == null && b == null) return 0;
      if (a == null) return 1;
      if (b == null) return -1;
      if (typeof a === 'number' && typeof b === 'number') return a - b;
      return String(a).localeCompare(String(b), undefined, { numeric: true, sensitivity: 'base' });
    }

    function sortRows(rows, tableKey) {
      const sort = state.sorts[tableKey];
      if (!sort) return rows;
      const direction = sort.dir === 'asc' ? 1 : -1;
      return [...rows].sort((a, b) => {
        const base = compareValues(a[sort.key], b[sort.key]);
        if (base !== 0) return base * direction;
        return compareValues(a.manager || a.name || a.position || a.year, b.manager || b.name || b.position || b.year);
      });
    }

    function refreshSortHeaderUi() {
      document.querySelectorAll('th.sortable').forEach((th) => {
        const table = th.closest('table')?.dataset.sortTable;
        const key = th.dataset.sortKey;
        const active = table && state.sorts[table] && state.sorts[table].key === key;
        th.dataset.sortDir = active ? state.sorts[table].dir : '';
      });
    }


    function includesAll(values) {
      return values.includes(ALL_OPTION_VALUE);
    }

    function normalizeSelection(selectedValues) {
      if (!selectedValues.length || selectedValues.includes(ALL_OPTION_VALUE)) return [ALL_OPTION_VALUE];
      return selectedValues;
    }

    function filterByManagerYearPosition(rows) {
      return rows.filter((row) => {
        if (!includesAll(state.manager) && !state.manager.includes(row.manager)) return false;
        if (!includesAll(state.year) && !state.year.includes(String(row.year))) return false;
        if (!includesAll(state.position) && !state.position.includes(row.position)) return false;
        return true;
      });
    }

    function buildRoundCostResolver(scopeRows) {
      const auctionRoundByRow = new Map();
      const byYear = new Map();

      scopeRows.forEach((row) => {
        if (row.auctionPrice == null) return;
        if (!byYear.has(row.year)) byYear.set(row.year, []);
        byYear.get(row.year).push(row);
      });

      byYear.forEach((rows) => {
        const managersInYear = new Set(rows.map((row) => row.manager)).size || 1;
        const sorted = [...rows].sort((a, b) => {
          if (a.auctionPrice !== b.auctionPrice) return b.auctionPrice - a.auctionPrice;
          return compareValues(a.overall, b.overall);
        });

        // Tie handling: players with equal auction prices share the same round-equivalent.
        // The shared round is based on the first rank where that price appears.
        for (let idx = 0; idx < sorted.length;) {
          const price = sorted[idx].auctionPrice;
          const startRank = idx + 1;
          const roundEquivalent = Math.ceil(startRank / managersInYear);

          let j = idx;
          while (j < sorted.length && sorted[j].auctionPrice === price) {
            auctionRoundByRow.set(sorted[j], roundEquivalent);
            j += 1;
          }
          idx = j;
        }
      });

      return (row) => {
        if (row.auctionPrice == null) return row.round ?? null;
        return auctionRoundByRow.get(row) ?? null;
      };
    }


    function syncRoundCostOptions(scopeRows, resolveRoundCostBucket) {
      const roundCosts = [...new Set(scopeRows.map((row) => resolveRoundCostBucket(row)).filter((v) => Number.isFinite(v) && v > 0))]
        .sort((a, b) => a - b)
        .map(String);

      const selected = state.roundCost.filter((value) => value === ALL_OPTION_VALUE || roundCosts.includes(value));
      state.roundCost = normalizeSelection(selected);

      roundCostSelect.innerHTML = `<option value="${ALL_OPTION_VALUE}"${includesAll(state.roundCost) ? ' selected' : ''}>All Round/Cost Tiers</option>${roundCosts
        .map((rc) => `<option value="${rc}"${state.roundCost.includes(rc) ? ' selected' : ''}>${rc}</option>`)
        .join('')}`;
    }

    function applyFilters(rows) {
      const scopeRows = filterByManagerYearPosition(rows);
      const resolveRoundCostBucket = buildRoundCostResolver(scopeRows);
      syncRoundCostOptions(scopeRows, resolveRoundCostBucket);

      return scopeRows.filter((row) => {
        if (!includesAll(state.roundCost) && !state.roundCost.includes(String(resolveRoundCostBucket(row)))) return false;
        return true;
      });
    }

    function getBestCorePosition(rows) {
      const core = ['QB', 'RB', 'WR', 'TE'];
      const byPos = new Map();
      rows.forEach((row) => {
        if (!core.includes(row.position) || row.percentileDelta == null) return;
        if (!byPos.has(row.position)) byPos.set(row.position, []);
        byPos.get(row.position).push(row.percentileDelta);
      });

      let bestPosition = '—';
      let bestScore = null;
      byPos.forEach((scores, position) => {
        const score = average(scores);
        if (bestScore == null || score > bestScore) {
          bestScore = score;
          bestPosition = position;
        }
      });
      return { bestPosition, bestScore };
    }

    function renderCards(filtered) {
      const qualified = filtered.filter((r) => r.valueScore != null);
      const avgScore = average(qualified.map((r) => r.valueScore));
      const strongCount = qualified.filter((r) => r.valueScore > 0).length;

      const bestPick = qualified.reduce((best, row) => {
        if (!best || row.valueScore > best.valueScore) return row;
        return best;
      }, null);

      document.getElementById('bestValuePick').textContent = bestPick ? bestPick.name : '—';
      document.getElementById('bestValuePickNote').textContent = bestPick
        ? `${bestPick.manager} • ${bestPick.year} ${bestPick.position} • ${formatScore(bestPick.valueScore)}`
        : 'No qualified picks in filter';
      document.getElementById('avgScore').textContent = formatScore(avgScore);
      document.getElementById('strongPickRate').textContent = qualified.length ? `${((strongCount / qualified.length) * 100).toFixed(1)}%` : '—';
      document.getElementById('qualifiedPicks').textContent = String(qualified.length);
    }

    function renderManagerLeaderboard(filtered) {
      const tbody = document.getElementById('managerLeaderboardBody');
      const grouped = new Map();
      filtered.forEach((row) => {
        if (!grouped.has(row.manager)) grouped.set(row.manager, []);
        grouped.get(row.manager).push(row);
      });

      let leaderboard = summarizeByManager(filtered).map((summary) => {
        const managerRows = grouped.get(summary.manager) || [];
        const eligible = managerRows.filter((r) => r.isRankEligible);
        const majorBusts = eligible.filter((r) => r.posRankDelta != null && r.posRankDelta <= -10).length;
        const safe = eligible.filter((r) => !(r.posRankDelta != null && r.posRankDelta <= -10)).length;
        const safetyRate = eligible.length ? safe / eligible.length : null;
        const bustRate = eligible.length ? majorBusts / eligible.length : null;
        const { bestPosition, bestScore } = getBestCorePosition(managerRows);

        return {
          manager: summary.manager,
          beatCostRate: summary.beatCostRate,
          avgPercentileDelta: summary.avgPercentileDelta,
          eligiblePicks: summary.eligiblePicks,
          safetyRate,
          bustRate,
          bestPosition,
          bestScore
        };
      });

      leaderboard = sortRows(leaderboard, 'managerLeaderboard').map((item, idx) => ({ ...item, rank: idx + 1 }));

      if (!leaderboard.length) {
        tbody.innerHTML = '<tr><td colspan="8">No manager data for this filter.</td></tr>';
        return;
      }

      const percentileBounds = minMax(leaderboard.map((item) => item.avgPercentileDelta).filter((v) => v != null));

      tbody.innerHTML = leaderboard.map((item) => `
        <tr>
          <td>${item.rank}</td>
          <td>${item.manager}</td>
          <td>${formatPct(item.beatCostRate)}</td>
          <td style="color: ${valueToHeatColor(item.avgPercentileDelta, percentileBounds.min, percentileBounds.max)}">${formatScore(item.avgPercentileDelta)}</td>
          <td>${item.bestPosition} (${formatScore(item.bestScore)})</td>
          <td>${formatPct(item.safetyRate)}</td>
          <td>${formatPct(item.bustRate)}</td>
          <td>${item.eligiblePicks}</td>
        </tr>
      `).join('');
    }

    function renderYearComparison(filtered) {
      const tbody = document.getElementById('yearComparisonBody');
      const byYearRows = new Map();
      filtered.forEach((row) => {
        if (!byYearRows.has(row.year)) byYearRows.set(row.year, []);
        byYearRows.get(row.year).push(row);
      });

      let rows = summarizeByYear(filtered).map((summary) => {
        const yearRows = byYearRows.get(summary.year) || [];
        const eligible = yearRows.filter((r) => r.isRankEligible);
        const hits = eligible.filter((r) => r.beatCost).length;
        const busts = eligible.filter((r) => r.missedCost).length;

        const posMap = new Map();
        eligible.forEach((r) => {
          if (!posMap.has(r.position)) posMap.set(r.position, []);
          if (r.percentileDelta != null) posMap.get(r.position).push(r.percentileDelta);
        });

        let topPos = '—';
        let topPosScore = null;
        posMap.forEach((values, pos) => {
          const avg = average(values);
          if (avg != null && (topPosScore == null || avg > topPosScore)) {
            topPos = pos;
            topPosScore = avg;
          }
        });

        return {
          year: summary.year,
          hits,
          busts,
          hitRate: summary.beatCostRate,
          bustRate: summary.eligiblePicks ? busts / summary.eligiblePicks : null,
          topPos,
          topPosScore
        };
      });

      rows = sortRows(rows, 'yearComparison');

      if (!rows.length) {
        tbody.innerHTML = '<tr><td colspan="6">No yearly data for this filter.</td></tr>';
        return;
      }

      tbody.innerHTML = rows.map((item) => `
        <tr>
          <td>${item.year}</td>
          <td>${item.hits}</td>
          <td>${item.busts}</td>
          <td>${formatPct(item.hitRate)}</td>
          <td>${formatPct(item.bustRate)}</td>
          <td>${item.topPos} (${formatScore(item.topPosScore)})</td>
        </tr>
      `).join('');
    }

    function renderPositionBreakdown(filtered) {
      const tbody = document.getElementById('positionBreakdownBody');
      const grouped = new Map();
      filtered.forEach((row) => {
        if (row.valueScore == null) return;
        if (!grouped.has(row.position)) grouped.set(row.position, []);
        grouped.get(row.position).push(row.valueScore);
      });

      let rows = [...grouped.entries()].map(([position, scores]) => {
        const avgScore = average(scores);
        const medianScore = median(scores);
        const strong = scores.filter((r) => r > 0).length;
        const strongRate = scores.length ? strong / scores.length : null;
        return { position, picks: scores.length, avgScore, medianScore, strong, strongRate };
      });

      rows = sortRows(rows, 'positionBreakdown');

      if (!rows.length) {
        tbody.innerHTML = '<tr><td colspan="5">No qualified picks available for this filter.</td></tr>';
        return;
      }

      tbody.innerHTML = rows.map((item) => `
          <tr>
            <td>${item.position}</td>
            <td>${item.picks}</td>
            <td class="${scoreClass(item.avgScore)}">${formatScore(item.avgScore)}</td>
            <td class="${scoreClass(item.medianScore)}">${formatScore(item.medianScore)}</td>
            <td>${item.strong} (${formatPct(item.strongRate)})</td>
          </tr>
        `).join('');
    }

    function renderAuctionBargains(filtered) {
      const tbody = document.getElementById('auctionBargainBody');
      let bargains = filtered
        .filter((row) => row.valueScore != null)
        .map((row) => ({
          ...row,
          draftType: row.auctionPrice == null ? 'Snake' : 'Auction',
          acquisitionCost: row.auctionPrice == null
            ? `Round ${row.round ?? '—'}${row.overall != null ? ` (Pick ${row.overall})` : ''}`
            : `$${row.auctionPrice}`
        }));

      bargains = sortRows(bargains, 'auctionBargains').slice(0, 25);

      if (!bargains.length) {
        tbody.innerHTML = '<tr><td colspan="8">No value-score data available for this filter.</td></tr>';
        return;
      }

      tbody.innerHTML = bargains.map((row) => `
        <tr>
          <td>${row.year}</td>
          <td>${row.name}</td>
          <td>${row.manager}</td>
          <td>${row.position}</td>
          <td>${row.draftType}</td>
          <td>${row.acquisitionCost}</td>
          <td>${row.finishRank ?? '—'}</td>
          <td class="${scoreClass(row.valueScore)}">${formatScore(row.valueScore, 3)}</td>
        </tr>
      `).join('');
    }

    function render() {
      const filtered = applyFilters(state.rows);
      renderCards(filtered);
      renderManagerLeaderboard(filtered);
      renderYearComparison(filtered);
      renderPositionBreakdown(filtered);
      renderAuctionBargains(filtered);
      refreshSortHeaderUi();
      statusEl.textContent = `${filtered.length} picks shown • ${filtered.filter((r) => r.valueScore != null).length} with value scores`;
    }


    const columnExplainers = {
      managerLeaderboard: {
        rank: 'Sort rank after applying current table sort settings.',
        manager: 'Draft manager/owner for the selected slice.',
        beatCostRate: 'Share of rank-eligible picks that beat draft cost. Equation: Beat Cost Rate = beatCost picks / eligible picks.',
        avgPercentileDelta: 'Average movement versus draft percentile. Equation: Avg Percentile Δ = mean(finishPercentile − draftPercentile). Positive is better.',
        bestPosition: "Manager's strongest core position (QB/RB/WR/TE) by average percentile delta.",
        safetyRate: 'How often filtered eligible picks avoided a major bust (worse than −10 rank delta). Equation: Safety Rate = safe eligible picks / eligible picks.',
        bustRate: 'Major bust frequency for filtered eligible picks. Equation: Bust Rate = major-bust eligible picks / eligible picks.',
        eligiblePicks: 'Count of picks with a valid positional finish rank used in rate calculations.'
      },
      yearComparison: {
        year: 'Draft season represented by the aggregated row.',
        hits: 'Number of eligible picks that beat draft cost in that season.',
        busts: 'Number of eligible picks that missed draft cost in that season.',
        hitRate: 'Season success rate. Equation: Hit Rate = value hits / eligible picks.',
        bustRate: 'Season miss rate. Equation: Bust Rate = busts / eligible picks.',
        topPosScore: 'Position with the strongest average percentile trend for that year.'
      },
      positionBreakdown: {
        position: 'Fantasy position bucket for the filtered picks.',
        picks: 'Number of qualified picks at this position.',
        avgScore: 'Mean value score. Equation: Avg Score = mean(ln(positional draft slot / finish rank)).',
        medianScore: 'Median of value score values to reduce outlier influence.',
        strongRate: 'Share of picks with positive value score. Equation: Strong Picks = positive-score picks / total picks.'
      },
      auctionBargains: {
        year: 'Draft season for this pick.',
        name: 'Player selected in either snake or auction format.',
        manager: 'Manager who drafted the player.',
        position: 'Player position bucket used in value calculations.',
        draftType: 'Draft format for that pick (Snake or Auction).',
        acquisitionCost: 'How the player was acquired: snake round/pick or auction dollar cost.',
        finishRank: 'End-of-year positional finish rank.',
        valueScore: 'Primary value metric. Equation: Value Score = ln(positional draft slot ÷ finish rank). Higher is better.'
      }
    };

    function applyColumnExplainers() {
      document.querySelectorAll('table[data-sort-table]').forEach((table) => {
        const tableKey = table.dataset.sortTable;
        const explainers = columnExplainers[tableKey] || {};
        table.querySelectorAll('th[data-sort-key]').forEach((th) => {
          const key = th.dataset.sortKey;
          const text = explainers[key];
          if (!text) return;
          th.dataset.tooltip = text;
          th.tabIndex = 0;
        });
      });
    }

    function wireSortableHeaders() {
      document.querySelectorAll('th.sortable').forEach((th) => {
        th.addEventListener('click', () => {
          const tableKey = th.closest('table')?.dataset.sortTable;
          const key = th.dataset.sortKey;
          if (!tableKey || !key) return;
          const current = state.sorts[tableKey];
          if (current.key === key) {
            current.dir = current.dir === 'asc' ? 'desc' : 'asc';
          } else {
            current.key = key;
            current.dir = key === 'manager' || key === 'position' || key === 'name' ? 'asc' : 'desc';
          }
          render();
        });
      });
    }

    function populateSelectors(rows) {
      const managers = [...new Set(rows.map((r) => r.manager))].sort();
      const years = [...new Set(rows.map((r) => r.year))].sort((a, b) => b - a);
      const orderedCorePositions = ['QB', 'RB', 'WR', 'TE'];
      const seenPositions = new Set(rows.map((r) => r.position));
      const positions = orderedCorePositions.filter((position) => seenPositions.has(position));

      managerSelect.innerHTML = `<option value="${ALL_OPTION_VALUE}" selected>All Managers</option>${managers.map((m) => `<option value="${m}">${m}</option>`).join('')}`;
      yearSelect.innerHTML = `<option value="${ALL_OPTION_VALUE}" selected>All Years</option>${years.map((y) => `<option value="${y}">${y}</option>`).join('')}`;
      positionSelect.innerHTML = `<option value="${ALL_OPTION_VALUE}" selected>All Positions</option>${positions.map((p) => `<option value="${p}">${p}</option>`).join('')}`;
      roundCostSelect.innerHTML = '';

      state.manager = [ALL_OPTION_VALUE];
      state.year = [ALL_OPTION_VALUE];
      state.position = [ALL_OPTION_VALUE];
      state.roundCost = [ALL_OPTION_VALUE];
    }

    function getSelectedValues(selectEl) {
      return [...selectEl.selectedOptions].map((option) => option.value);
    }

    async function init() {
      try {
        const response = await fetch('draft-history-2.json');
        if (!response.ok) throw new Error(`Failed to load draft-history-2.json (${response.status})`);

        const raw = await response.json();
        const enrichedRows = enrichDraftEntries(raw);

        state.rows = enrichedRows.map((row) => {
          const valueScore = row.valueRatio != null ? Math.log(row.valueRatio) : null;
          return {
            ...row,
            manager: row.managerValue || row.manager || 'Unknown Manager',
            position: row.normalizedPosition,
            valueScore
          };
        });


        populateSelectors(state.rows);
        wireSortableHeaders();
        applyColumnExplainers();
        managerSelect.addEventListener('change', () => { state.manager = normalizeSelection(getSelectedValues(managerSelect)); render(); });
        yearSelect.addEventListener('change', () => { state.year = normalizeSelection(getSelectedValues(yearSelect)); render(); });
        positionSelect.addEventListener('change', () => { state.position = normalizeSelection(getSelectedValues(positionSelect)); render(); });
        roundCostSelect.addEventListener('change', () => { state.roundCost = normalizeSelection(getSelectedValues(roundCostSelect)); render(); });

        render();
      } catch (error) {
        console.error(error);
        statusEl.textContent = 'Unable to load draft analytics data.';
      }
    }

    init();
  </script>
</body>
</html>
