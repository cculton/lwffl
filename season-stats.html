<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Season By Season Stats – LWFFL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-main: #020617;
      --card-bg: #020617;
      --accent: #38bdf8;
      --border-subtle: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;
      --positive: #22c55e;
      --negative: #ef4444;
      --sorted-header-bg: rgba(15, 23, 42, 0.95);
      --sorted-cell-bg: rgba(15, 23, 42, 0.88);
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 35%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 24px 16px;
    }

    .shell {
      max-width: 1200px;
      margin: 0 auto;
    }

    .container {
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), transparent 55%),
        radial-gradient(circle at bottom right, rgba(59, 130, 246, 0.18), transparent 55%),
        var(--card-bg);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow:
        0 40px 80px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      padding: 28px 24px 28px;
      backdrop-filter: blur(14px);
    }

    .header {
      text-align: center;
      margin-bottom: 24px;
    }

    .header h1 {
      font-size: 2rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-weight: 700;
      margin-bottom: 6px;
      color: #f9fafb;
    }

    .header p {
      color: var(--text-soft);
      font-size: 0.9rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 16px;
      margin-bottom: 24px;
      align-items: flex-end;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      position: relative; /* Needed for dropdown positioning */
    }

    label {
      margin-bottom: 6px;
      color: var(--text-muted);
      font-weight: 600;
      font-size: 0.8rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    /* --- Custom Multi-Select Styles --- */
    .multi-select-box {
      background-color: #0b1120;
      border: 1px solid rgba(75, 85, 99, 0.9);
      border-radius: 10px;
      padding: 10px 12px;
      color: #f9fafb;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.7);
    }

    .multi-select-box:hover {
      border-color: var(--accent);
    }

    .multi-select-label {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-right: 10px;
    }

    .dropdown-arrow {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: #0b1120;
      border: 1px solid rgba(56, 189, 248, 0.5);
      border-radius: 10px;
      margin-top: 6px;
      z-index: 50;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0,0,0,0.8);
    }

    .dropdown-menu.open {
      display: block;
    }

    .dropdown-item {
      padding: 8px 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      border-bottom: 1px solid rgba(31, 41, 55, 0.5);
      transition: background 0.1s;
    }

    .dropdown-item:last-child {
      border-bottom: none;
    }

    .dropdown-item:hover {
      background-color: rgba(56, 189, 248, 0.15);
    }

    .dropdown-item input[type="checkbox"] {
      appearance: none;
      width: 16px;
      height: 16px;
      border: 1px solid var(--text-muted);
      border-radius: 3px;
      background: transparent;
      cursor: pointer;
      display: grid;
      place-content: center;
    }

    .dropdown-item input[type="checkbox"]::before {
      content: "";
      width: 10px;
      height: 10px;
      transform: scale(0);
      transition: 120ms transform ease-in-out;
      box-shadow: inset 1em 1em var(--accent);
      transform-origin: center;
      clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
    }

    .dropdown-item input[type="checkbox"]:checked::before {
      transform: scale(1);
    }

    .dropdown-item input[type="checkbox"]:checked {
      border-color: var(--accent);
    }
    
    .select-all-row {
      background-color: rgba(15, 23, 42, 0.95);
      position: sticky;
      top: 0;
      z-index: 2;
      border-bottom: 1px solid rgba(56, 189, 248, 0.3);
      font-weight: 600;
      color: var(--accent);
    }
    /* -------------------------------- */

    .hint {
      font-size: 0.8rem;
      color: var(--text-soft);
      text-align: right;
    }

    .leaderboard-card {
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.97), rgba(15, 23, 42, 0.99));
      border-radius: 14px;
      border: 1px solid rgba(31, 41, 55, 0.95);
      box-shadow:
        0 20px 40px rgba(15, 23, 42, 0.95),
        0 0 0 1px rgba(15, 23, 42, 0.95);
      padding: 18px 16px 16px;
    }

    .leaderboard-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 16px;
      gap: 12px;
      flex-wrap: wrap;
    }

    .leaderboard-title {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #e5e7eb;
      margin-bottom: 6px;
    }

    .leaderboard-subtitle {
      font-size: 0.8rem;
      color: var(--text-soft);
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .table-wrap {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      border-radius: 10px;
    }

    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      min-width: 1100px; 
      border-radius: 10px;
      overflow: hidden;
    }

    .leaderboard-table thead {
      background: linear-gradient(90deg, #020617, #020617);
    }

    .leaderboard-table th {
      padding: 10px 10px; 
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: #9ca3af;
      border-bottom: 1px solid rgba(55, 65, 81, 0.9);
      white-space: nowrap;
      cursor: pointer;
      user-select: none;
      text-align: left;
    }

    .leaderboard-table tbody tr {
      transition: background 0.15s ease, transform 0.08s ease;
    }

    .leaderboard-table tbody tr:nth-child(odd) {
      background: #020617;
    }

    .leaderboard-table tbody tr:nth-child(even) {
      background: #020617;
    }

    .leaderboard-table tbody tr:hover {
      background: rgba(15, 23, 42, 0.98);
      transform: translateY(-1px);
    }

    .leaderboard-table td {
      padding: 9px 10px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.96);
      color: var(--text-main);
      text-align: left;
      font-variant-numeric: tabular-nums;
    }

    .leaderboard-table tbody tr:last-child td {
      border-bottom: none;
    }

    .rank-cell {
      font-weight: 600;
      color: var(--text-muted);
      width: 50px;
    }

    .year-cell {
      width: 70px;
      color: var(--text-main);
    }

    .manager-cell {
      font-weight: 500;
      white-space: nowrap;
    }

    .value-positive {
      color: var(--positive);
      font-weight: 600;
    }

    .value-negative {
      color: var(--negative);
      font-weight: 600;
    }

    .top-rank {
      background: radial-gradient(circle at left, rgba(56, 189, 248, 0.16), transparent 60%);
      box-shadow: inset 2px 0 0 rgba(56, 189, 248, 0.8);
    }

    .sorted-col-header {
      background: var(--sorted-header-bg);
      color: #e5e7eb;
    }

    .sorted-col-cell {
      background: var(--sorted-cell-bg);
    }

    .no-data {
      font-size: 0.9rem;
      color: var(--text-soft);
      padding: 14px 8px 4px;
    }

    .no-data span {
      border-radius: 999px;
      border: 1px dashed rgba(75,85,99,0.9);
      padding: 6px 10px;
      display: inline-flex;
      gap: 6px;
      align-items: center;
      background: rgba(15,23,42,0.85);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .footer-note {
      margin-top: 14px;
      font-size: 0.75rem;
      color: var(--text-soft);
      text-align: right;
    }

    @media (max-width: 900px) {
      .controls {
        grid-template-columns: 1fr;
      }

      .hint {
        text-align: left;
      }
    }

    @media (max-width: 600px) {
      .container {
        padding: 22px 14px 20px;
      }
      .header h1 {
        font-size: 1.4rem;
      }
      .leaderboard-title {
        font-size: 1rem;
      }
      .leaderboard-table th,
      .leaderboard-table td {
        padding: 7px 6px;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="container">
      <header class="header">
        <h1>Season By Season Stats</h1>
        <p>Legion of Whom Fantasy Football League  · 2014–Present</p>
      </header>

      <section class="controls">
        <div class="control-group" id="managerControl">
          <label>Manager</label>
          <div class="multi-select-box" onclick="toggleDropdown('manager')">
            <span class="multi-select-label" id="managerLabel">All Managers</span>
            <span class="dropdown-arrow">▼</span>
          </div>
          <div class="dropdown-menu" id="managerDropdown">
            </div>
        </div>

        <div class="control-group" id="yearControl">
          <label>Season</label>
          <div class="multi-select-box" onclick="toggleDropdown('year')">
            <span class="multi-select-label" id="yearLabel">All Seasons</span>
            <span class="dropdown-arrow">▼</span>
          </div>
          <div class="dropdown-menu" id="yearDropdown">
            </div>
        </div>

        <div class="control-group">
          <div class="hint">
            Select multiple options to compare specific eras or rivals.
          </div>
        </div>
      </section>

      <section class="leaderboard-card">
        <div class="leaderboard-header">
          <div>
            <div class="leaderboard-title" id="leaderboardTitle">
              All Seasons · All Managers
            </div>
            <div class="leaderboard-subtitle" id="leaderboardSubtitle">
              Filtered Data View
            </div>
          </div>
        </div>

        <div class="table-wrap">
          <table class="leaderboard-table" aria-live="polite">
            <thead>
              <tr id="headerRow"></tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>

        <div class="no-data" id="noDataMessage" style="display: none;">
          <span>Note · No data for this combination yet</span>
        </div>

        <div class="footer-note">
          Data source: <strong>final-standings.json</strong> & <strong>playoff-seeds.json</strong>
        </div>
      </section>
    </div>
  </div>

  <script>
    let allSeasons = [];
    let currentSort = {
      columnKey: "points_for",
      direction: "desc"
    };

    // Filter States
    let selectedManagers = []; // empty implies ALL
    let selectedYears = [];    // empty implies ALL

    const headerDefs = [
      { key: "rank", label: "Rank" },
      { key: "year", label: "Season" },
      { key: "manager", label: "Manager" },
      { key: "wins", label: "W" },
      { key: "losses", label: "L" },
      { key: "ties", label: "T" },
      { key: "games", label: "M" },
      { key: "points_for", label: "PF" },
      { key: "points_against", label: "PA" },
      { key: "ppm_for", label: "PPM" },
      { key: "ppm_against", label: "PAPM" },
      { key: "weekly_margin", label: "MARG" },
      { key: "division_finish", label: "DF" },
      { key: "playoff_seed", label: "PS" },
      { key: "final_standing", label: "FS" },
      { key: "transaction_count", label: "TRANS" }
    ];

    function getHeaderTitle(label) {
      switch (label) {
        case "Rank": return "Rank within the current filter";
        case "Season": return "League season year";
        case "Manager": return "Manager name";
        case "W": return "Season wins";
        case "L": return "Season losses";
        case "T": return "Season ties";
        case "M": return "Total number of matchups played that season";
        case "PF": return "Total points scored by this team that season";
        case "PA": return "Total points scored against this team that season";
        case "PPM": return "Points scored per matchup (points for ÷ matchups)";
        case "PAPM": return "Points against per matchup (points against ÷ matchups)";
        case "MARG": return "Average weekly scoring margin (points for − points against)";
        case "DF": return "Division finishing position";
        case "PS": return "Playoff Seed (if applicable)";
        case "FS": return "Final league standing at end of season";
        case "TRANS": return "Number of transactions made that season";
        default: return label;
      }
    }

    function formatNumber(value, digits = 1) {
      if (value === null || value === undefined || Number.isNaN(value)) return "—";
      return value.toLocaleString("en-US", {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits
      });
    }

    function formatInteger(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return "—";
      return value.toLocaleString("en-US", { maximumFractionDigits: 0 });
    }

    function decorateRow(raw) {
      const wins = raw.wins ?? 0;
      const losses = raw.losses ?? 0;
      const ties = raw.ties ?? 0;
      const games = wins + losses + ties;
      const pf = raw.points_for ?? null;
      const pa = raw.points_against ?? null;

      const ppmFor = games && pf !== null ? pf / games : null;
      const ppmAgainst = games && pa !== null ? pa / games : null;

      const record = ties ? `${wins}-${losses}-${ties}` : `${wins}-${losses}`;

      return {
        ...raw,
        wins,
        losses,
        ties,
        games,
        ppm_for: ppmFor,
        ppm_against: ppmAgainst,
        record
      };
    }

    // --- Multi-Select Logic ---

    function toggleDropdown(type) {
      const menu = document.getElementById(`${type}Dropdown`);
      const isOpen = menu.classList.contains("open");
      // Close all first
      document.querySelectorAll(".dropdown-menu").forEach(el => el.classList.remove("open"));
      if (!isOpen) {
        menu.classList.add("open");
      }
    }

    // Close dropdowns when clicking outside
    document.addEventListener("click", (e) => {
      if (!e.target.closest(".control-group")) {
        document.querySelectorAll(".dropdown-menu").forEach(el => el.classList.remove("open"));
      }
    });

    function createDropdownItem(text, value, type, isSelectAll = false) {
      const div = document.createElement("div");
      div.className = "dropdown-item";
      if (isSelectAll) div.classList.add("select-all-row");
      
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = value;
      
      // Initial check state
      if (isSelectAll) {
        const list = type === 'manager' ? selectedManagers : selectedYears;
        checkbox.checked = (list.length === 0); // Empty list = All Selected
        checkbox.addEventListener("change", () => handleSelectAll(type, checkbox.checked));
      } else {
        const list = type === 'manager' ? selectedManagers : selectedYears;
        // If list is empty (ALL), check everything visually
        checkbox.checked = list.length === 0 || list.includes(value);
        checkbox.addEventListener("change", () => handleItemSelect(type, value, checkbox.checked));
      }

      const label = document.createElement("span");
      label.textContent = text;

      div.appendChild(checkbox);
      div.appendChild(label);
      div.onclick = (e) => {
        if (e.target !== checkbox) {
          checkbox.checked = !checkbox.checked;
          checkbox.dispatchEvent(new Event("change"));
        }
      };

      return div;
    }

    function handleSelectAll(type, isChecked) {
      if (type === 'manager') selectedManagers = []; // Clear to imply ALL
      if (type === 'year') selectedYears = [];       // Clear to imply ALL
      
      refreshDropdownUI(type);
      renderTable();
    }

    function handleItemSelect(type, value, isChecked) {
      let list = type === 'manager' ? selectedManagers : selectedYears;
      let allPossible = type === 'manager' 
        ? Array.from(new Set(allSeasons.map(r => r.manager))).filter(Boolean)
        : Array.from(new Set(allSeasons.map(r => String(r.year))));
      
      // If list was empty (ALL mode), and we uncheck one, we must populate list with everything else
      if (list.length === 0 && !isChecked) {
        list = allPossible.filter(item => item !== value);
      } 
      // If list was empty (ALL mode) and we check one... wait, standard logic:
      // If currently "ALL", all checkboxes are visually checked. 
      // Unchecking one enters "Specific" mode.
      else if (list.length === 0 && isChecked) {
         // This state shouldn't happen via UI click because they are already checked.
         // But if logic shifts:
         // If we are in "Specific" mode:
      } else {
         if (isChecked) {
           list.push(value);
         } else {
           list = list.filter(item => item !== value);
         }
      }

      // If we selected everything manually, revert to empty (ALL) state
      if (list.length === allPossible.length) {
        list = [];
      }

      // Update global state
      if (type === 'manager') selectedManagers = list;
      else selectedYears = list;

      refreshDropdownUI(type);
      renderTable();
    }

    function refreshDropdownUI(type) {
      // Re-render checkboxes based on current state
      // This is simpler than toggling DOM elements individually
      if (type === 'manager') populateManagerDropdown();
      else populateYearDropdown();
      updateLabel(type);
    }

    function updateLabel(type) {
      const labelEl = document.getElementById(`${type}Label`);
      const list = type === 'manager' ? selectedManagers : selectedYears;
      
      if (list.length === 0) {
        labelEl.textContent = type === 'manager' ? "All Managers" : "All Seasons";
      } else if (list.length === 1) {
        labelEl.textContent = list[0];
      } else {
        labelEl.textContent = `${list.length} Selected`;
      }
    }

    function populateManagerDropdown() {
      const container = document.getElementById("managerDropdown");
      container.innerHTML = "";
      
      const managers = Array.from(
        new Set(
          allSeasons.map(r => r.manager).filter(m => m && m.trim().length > 0)
        )
      ).sort((a, b) => a.localeCompare(b));

      // Select All Option
      container.appendChild(createDropdownItem("Select All", "all", "manager", true));

      managers.forEach(m => {
        container.appendChild(createDropdownItem(m, m, "manager"));
      });
    }

    function populateYearDropdown() {
      const container = document.getElementById("yearDropdown");
      container.innerHTML = "";

      const years = Array.from(
        new Set(allSeasons.map(r => r.year))
      ).sort((a, b) => b - a);

      // Select All Option
      container.appendChild(createDropdownItem("Select All", "all", "year", true));

      years.forEach(y => {
        container.appendChild(createDropdownItem(String(y), String(y), "year"));
      });
    }

    function getFilteredRows() {
      return allSeasons
        .map(decorateRow)
        .filter(r => {
          // Check Managers
          if (selectedManagers.length > 0 && !selectedManagers.includes(r.manager)) {
            return false;
          }
          // Check Years
          if (selectedYears.length > 0 && !selectedYears.includes(String(r.year))) {
             return false;
          }
          return true;
        });
    }

    function compareValues(a, b, key, direction) {
      const dir = direction === "asc" ? 1 : -1;
      const va = a[key];
      const vb = b[key];

      if (va === null || va === undefined) return 1 * dir;
      if (vb === null || vb === undefined) return -1 * dir;

      if (typeof va === "string" || typeof vb === "string") {
        const cmp = String(va).localeCompare(String(vb));
        return cmp * dir;
      }

      if (va === vb) return 0;
      return va > vb ? dir : -dir;
    }

    function getDefaultDirectionForColumn(colKey) {
      if (colKey === "manager") return "asc";
      if (colKey === "year") return "desc";
      if (colKey === "final_standing" || colKey === "division_finish" || colKey === "playoff_seed") return "asc";
      if (colKey === "points_for") return "desc";
      return "desc";
    }

    function renderTable() {
      const headerRow = document.getElementById("headerRow");
      const tbody = document.getElementById("leaderboardBody");
      const noDataMessage = document.getElementById("noDataMessage");
      const titleEl = document.getElementById("leaderboardTitle");

      const filtered = getFilteredRows();

      // Dynamic Title
      const mCount = selectedManagers.length === 0 ? "All Managers" : 
                     selectedManagers.length === 1 ? selectedManagers[0] : "Multiple Managers";
      const yCount = selectedYears.length === 0 ? "All Seasons" : 
                     selectedYears.length === 1 ? `${selectedYears[0]} Season` : "Multiple Seasons";
      
      titleEl.textContent = `${yCount} · ${mCount}`;

      if (!filtered.length) {
        headerRow.innerHTML = "";
        tbody.innerHTML = "";
        noDataMessage.style.display = "block";
        noDataMessage.firstElementChild.textContent = "Note · No data for this combination yet";
        return;
      }

      const sortKey = currentSort.columnKey || "points_for";
      const direction = currentSort.direction || "desc";

      filtered.sort((a, b) => {
        if (sortKey === "rank") {
          if (a.year !== b.year) return (b.year - a.year);
          const fa = a.final_standing ?? Number.POSITIVE_INFINITY;
          const fb = b.final_standing ?? Number.POSITIVE_INFINITY;
          if (fa !== fb) return fa - fb;
          return a.manager.localeCompare(b.manager);
        }

        const primary = compareValues(a, b, sortKey, direction);
        if (primary !== 0) return primary;

        if (a.year !== b.year) return b.year - a.year;
        const fa = a.final_standing ?? Number.POSITIVE_INFINITY;
        const fb = b.final_standing ?? Number.POSITIVE_INFINITY;
        if (fa !== fb) return fa - fb;
        return a.manager.localeCompare(b.manager);
      });

      headerRow.innerHTML = "";
      headerDefs.forEach(def => {
        const th = document.createElement("th");
        th.textContent = def.label;
        th.title = getHeaderTitle(def.label);
        th.dataset.colKey = def.key;
        if (currentSort.columnKey === def.key) {
          th.classList.add("sorted-col-header");
        }
        headerRow.appendChild(th);
      });

      tbody.innerHTML = "";
      filtered.forEach((row, index) => {
        const tr = document.createElement("tr");
        if (index === 0) tr.classList.add("top-rank");

        const sortedKey = currentSort.columnKey;

        // Helper to check sort
        const isSort = (key) => sortedKey === key;

        // Rank
        const rankTd = document.createElement("td");
        rankTd.className = "rank-cell";
        rankTd.textContent = index + 1;
        if (isSort("rank")) rankTd.classList.add("sorted-col-cell");
        tr.appendChild(rankTd);

        // Season
        const yearTd = document.createElement("td");
        yearTd.className = "year-cell";
        yearTd.textContent = row.year ?? "—";
        if (isSort("year")) yearTd.classList.add("sorted-col-cell");
        tr.appendChild(yearTd);

        // Manager
        const managerTd = document.createElement("td");
        managerTd.className = "manager-cell";
        managerTd.textContent = row.manager || "—";
        if (isSort("manager")) managerTd.classList.add("sorted-col-cell");
        tr.appendChild(managerTd);

        // W
        const winsTd = document.createElement("td");
        winsTd.textContent = formatInteger(row.wins);
        if (isSort("wins")) winsTd.classList.add("sorted-col-cell");
        tr.appendChild(winsTd);

        // L
        const lossesTd = document.createElement("td");
        lossesTd.textContent = formatInteger(row.losses);
        if (isSort("losses")) lossesTd.classList.add("sorted-col-cell");
        tr.appendChild(lossesTd);

        // T
        const tiesTd = document.createElement("td");
        tiesTd.textContent = formatInteger(row.ties);
        if (isSort("ties")) tiesTd.classList.add("sorted-col-cell");
        tr.appendChild(tiesTd);

        // M
        const gamesTd = document.createElement("td");
        gamesTd.textContent = formatInteger(row.games);
        if (isSort("games")) gamesTd.classList.add("sorted-col-cell");
        tr.appendChild(gamesTd);

        // PF
        const pfTd = document.createElement("td");
        pfTd.classList.add("value-positive");
        pfTd.textContent = formatNumber(row.points_for, 1);
        if (isSort("points_for")) pfTd.classList.add("sorted-col-cell");
        tr.appendChild(pfTd);

        // PA
        const paTd = document.createElement("td");
        paTd.classList.add("value-negative");
        paTd.textContent = formatNumber(row.points_against, 1);
        if (isSort("points_against")) paTd.classList.add("sorted-col-cell");
        tr.appendChild(paTd);

        // PPM
        const ppmForTd = document.createElement("td");
        ppmForTd.classList.add("value-positive");
        ppmForTd.textContent = row.ppm_for === null ? "—" : formatNumber(row.ppm_for, 1);
        if (isSort("ppm_for")) ppmForTd.classList.add("sorted-col-cell");
        tr.appendChild(ppmForTd);

        // PAPM
        const ppmAgainstTd = document.createElement("td");
        ppmAgainstTd.classList.add("value-negative");
        ppmAgainstTd.textContent = row.ppm_against === null ? "—" : formatNumber(row.ppm_against, 1);
        if (isSort("ppm_against")) ppmAgainstTd.classList.add("sorted-col-cell");
        tr.appendChild(ppmAgainstTd);

        // MARG
        const marginTd = document.createElement("td");
        if (row.weekly_margin != null) {
          let formatted = formatNumber(row.weekly_margin, 1);
          if (row.weekly_margin > 0) {
            formatted = "+" + formatted;
            marginTd.classList.add("value-positive");
          } else if (row.weekly_margin < 0) {
            marginTd.classList.add("value-negative");
          }
          marginTd.textContent = formatted;
        } else {
          marginTd.textContent = "—";
        }
        if (isSort("weekly_margin")) marginTd.classList.add("sorted-col-cell");
        tr.appendChild(marginTd);

        // DF
        const divTd = document.createElement("td");
        divTd.textContent = row.division_finish != null ? formatInteger(row.division_finish) : "—";
        if (isSort("division_finish")) divTd.classList.add("sorted-col-cell");
        tr.appendChild(divTd);

        // PS
        const seedTd = document.createElement("td");
        seedTd.textContent = row.playoff_seed != null ? formatInteger(row.playoff_seed) : "—";
        if (isSort("playoff_seed")) seedTd.classList.add("sorted-col-cell");
        tr.appendChild(seedTd);

        // FS
        const finalTd = document.createElement("td");
        finalTd.textContent = row.final_standing != null ? formatInteger(row.final_standing) : "—";
        if (isSort("final_standing")) finalTd.classList.add("sorted-col-cell");
        tr.appendChild(finalTd);

        // TRANS
        const txTd = document.createElement("td");
        txTd.textContent = row.transaction_count != null ? formatInteger(row.transaction_count) : "—";
        if (isSort("transaction_count")) txTd.classList.add("sorted-col-cell");
        tr.appendChild(txTd);

        tbody.appendChild(tr);
      });

      noDataMessage.style.display = "none";

      headerRow.onclick = (e) => {
        const th = e.target.closest("th");
        if (!th) return;
        const colKey = th.dataset.colKey;
        if (!colKey) return;

        if (colKey === "rank") {
          currentSort = { columnKey: "points_for", direction: "desc" };
        } else {
          let newDir = "desc";
          if (currentSort.columnKey === colKey) {
            newDir = currentSort.direction === "asc" ? "desc" : "asc";
          } else {
            newDir = getDefaultDirectionForColumn(colKey);
          }
          currentSort = { columnKey: colKey, direction: newDir };
        }
        renderTable();
      };
    }

    async function loadData() {
      try {
        const [standings, seeds] = await Promise.all([
          fetch("final-standings.json").then(r => r.json()),
          fetch("playoff-seeds.json").then(r => r.json())
        ]);
        
        // Merge seeds into standings
        const seedMap = {};
        seeds.forEach(s => {
          if (s.manager && s.year) {
            seedMap[`${s.manager}_${s.year}`] = s.seed;
          }
        });

        const merged = standings.map(row => {
          const key = `${row.manager}_${row.year}`;
          return {
            ...row,
            playoff_seed: seedMap[key] || null
          };
        });

        return merged;
      } catch (err) {
        console.error("Error loading JSON data", err);
        return [];
      }
    }

    document.addEventListener("DOMContentLoaded", async () => {
      allSeasons = await loadData();
      
      // Initialize Dropdowns
      populateManagerDropdown();
      populateYearDropdown();

      // Initial Render
      renderTable();
    });
  </script>
</body>
</html>
