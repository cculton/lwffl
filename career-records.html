<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Career Leaders – Legion of Whom FFL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-main: #020617;
      --card-bg: #020617;
      --accent: #38bdf8;
      --border-subtle: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;
      --positive: #22c55e;
      --negative: #ef4444;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 35%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 24px 16px;
    }

    .shell {
      max-width: 1100px;
      margin: 0 auto;
    }

    .container {
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), transparent 55%),
        radial-gradient(circle at bottom right, rgba(59, 130, 246, 0.18), transparent 55%),
        var(--card-bg);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow:
        0 40px 80px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      padding: 28px 24px 28px;
      backdrop-filter: blur(14px);
    }

    .header {
      text-align: center;
      margin-bottom: 24px;
    }

    .header h1 {
      font-size: 2rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-weight: 700;
      margin-bottom: 6px;
      color: #f9fafb;
    }

    .header p {
      color: var(--text-soft);
      font-size: 0.9rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 16px;
      margin-bottom: 24px;
      align-items: flex-end;
    }

    .control-group {
      display: flex;
      flex-direction: column;
    }

    label {
      margin-bottom: 6px;
      color: var(--text-muted);
      font-weight: 600;
      font-size: 0.8rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    /* Dropdowns – more readable across browsers (including Safari) */
    select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background-color: #0b1120;
      color: #f9fafb;
      font-size: 0.95rem;
      font-weight: 500;
      line-height: 1.4;
      outline: none;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.7);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    select:focus {
      border-color: var(--accent);
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.7),
        0 0 12px rgba(56, 189, 248, 0.45);
    }

    optgroup {
      background-color: #020617;
      color: var(--text-soft);
      font-style: normal;
      font-size: 0.8rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    select option {
      background-color: #020617;
      color: #f9fafb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .hint {
      font-size: 0.8rem;
      color: var(--text-soft);
      text-align: right;
    }

    .leaderboard-card {
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.97), rgba(15, 23, 42, 0.99));
      border-radius: 14px;
      border: 1px solid rgba(31, 41, 55, 0.95);
      box-shadow:
        0 20px 40px rgba(15, 23, 42, 0.95),
        0 0 0 1px rgba(15, 23, 42, 0.95);
      padding: 18px 16px 16px;
    }

    .leaderboard-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 12px;
      gap: 12px;
      flex-wrap: wrap;
    }

    .leaderboard-title {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .leaderboard-subtitle {
      font-size: 0.8rem;
      color: var(--text-soft);
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
      opacity: 0.8;
    }

    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      border-radius: 10px;
      overflow: hidden;
    }

    .leaderboard-table thead {
      background: linear-gradient(90deg, #020617, #020617);
    }

    .leaderboard-table th {
      padding: 8px 10px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: #9ca3af;
      border-bottom: 1px solid rgba(55, 65, 81, 0.9);
      white-space: nowrap;
      cursor: pointer;
      user-select: none;
    }

    .th-left {
      text-align: left;
    }

    .th-right {
      text-align: right;
    }

    .leaderboard-table tbody tr {
      transition: background 0.15s ease, transform 0.08s ease;
    }

    .leaderboard-table tbody tr:nth-child(odd) {
      background: #020617;
    }

    .leaderboard-table tbody tr:nth-child(even) {
      background: #020617;
    }

    .leaderboard-table tbody tr:hover {
      background: rgba(15, 23, 42, 0.98);
      transform: translateY(-1px);
    }

    .leaderboard-table td {
      padding: 9px 10px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.96);
      color: var(--text-main);
    }

    .leaderboard-table tbody tr:last-child td {
      border-bottom: none;
    }

    .rank-cell {
      font-weight: 600;
      color: var(--text-muted);
      width: 60px;
      text-align: left;
    }

    .manager-cell {
      font-weight: 500;
      white-space: nowrap;
      text-align: left;
    }

    .stat-cell {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .value-positive {
      color: var(--positive);
      font-weight: 600;
    }

    .value-negative {
      color: var(--negative);
      font-weight: 600;
    }

    .top-rank {
      background: radial-gradient(circle at left, rgba(56, 189, 248, 0.16), transparent 60%);
      box-shadow: inset 2px 0 0 rgba(56, 189, 248, 0.8);
    }

    .no-data {
      font-size: 0.9rem;
      color: var(--text-soft);
      padding: 14px 8px 4px;
    }

    .no-data span {
      border-radius: 999px;
      border: 1px dashed rgba(75,85,99,0.9);
      padding: 6px 10px;
      display: inline-flex;
      gap: 6px;
      align-items: center;
      background: rgba(15,23,42,0.85);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .footer-note {
      margin-top: 14px;
      font-size: 0.75rem;
      color: var(--text-soft);
      text-align: right;
    }

    @media (max-width: 900px) {
      .controls {
        grid-template-columns: 1fr;
      }

      .hint {
        text-align: left;
      }
    }

    @media (max-width: 600px) {
      .container {
        padding: 22px 14px 20px;
      }

      .header h1 {
        font-size: 1.4rem;
      }

      .leaderboard-title {
        font-size: 1rem;
      }

      .leaderboard-table th,
      .leaderboard-table td {
        padding: 7px 6px;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="container">
      <header class="header">
        <h1>Career Leaders</h1>
        <p>Legion of Whom Fantasy Football League</p>
      </header>

      <section class="controls">
        <div class="control-group">
          <label for="matchupTypeSelect">Matchup Type</label>
          <select id="matchupTypeSelect"></select>
        </div>
        <div class="control-group">
          <label for="categorySelect">Stat Category</label>
          <select id="categorySelect"></select>
        </div>
        <div class="control-group">
          <div class="hint">
            Career records with contextual stats (games, PPM, win %, streaks).
          </div>
        </div>
      </section>

      <section class="leaderboard-card">
        <div class="leaderboard-header">
          <div>
            <div class="leaderboard-title" id="leaderboardTitle">Most Points For · All Matchups</div>
            <div class="leaderboard-subtitle" id="leaderboardSubtitle">
              Career leaders with matchup context
            </div>
          </div>
          <div class="pill">
            <span class="pill-dot"></span>
            <span id="pillLabel">All Matchups</span>
          </div>
        </div>

        <table class="leaderboard-table" aria-live="polite">
          <thead>
            <tr id="headerRow"></tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>

        <div class="no-data" id="noDataMessage" style="display: none;">
          <span>Note · No data for this category &amp; matchup type yet</span>
        </div>

        <div class="footer-note">
          Data source: <strong>league-scores.json</strong> in this repo.
        </div>
      </section>
    </div>
  </div>

  <script>
    // === Global data containers ===
    let aggregatesByScope = {};
    let streaksByScope = {};
    let rawMatchups = [];

    const MATCHUP_TYPES = [
      "All Matchups",
      "Regular Season Matchups",
      "Playoff Matchups"
    ];

    // Category definitions
    const CATEGORY_DEFS = [
      // SCORING – FOR
      {
        label: "Most Points For",
        group: "Scoring (Points For)",
        sortKey: "pointsFor",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "pointsFor", label: "Pts For", format: "points", polarity: "positivePrimary" },
          { key: "games", label: "G", format: "integer" },
          { key: "ppmFor", label: "PPM", format: "ppm", polarity: "positive" }
        ]
      },
      {
        label: "Fewest Points For",
        group: "Scoring (Points For)",
        sortKey: "pointsFor",
        sortDir: "asc",
        type: "aggregate",
        columns: [
          { key: "pointsFor", label: "Pts For", format: "points", polarity: "negativePrimary" },
          { key: "games", label: "G", format: "integer" },
          { key: "ppmFor", label: "PPM", format: "ppm", polarity: "negative" }
        ]
      },
      {
        label: "Highest Points Per Matchup (PPM)",
        group: "Scoring (Points For)",
        sortKey: "ppmFor",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "ppmFor", label: "PPM", format: "ppm", polarity: "positivePrimary" },
          { key: "pointsFor", label: "Pts For", format: "points" },
          { key: "games", label: "G", format: "integer" }
        ]
      },
      {
        label: "Lowest Points Per Matchup (PPM)",
        group: "Scoring (Points For)",
        sortKey: "ppmFor",
        sortDir: "asc",
        type: "aggregate",
        columns: [
          { key: "ppmFor", label: "PPM", format: "ppm", polarity: "negativePrimary" },
          { key: "pointsFor", label: "Pts For", format: "points" },
          { key: "games", label: "G", format: "integer" }
        ]
      },

      // SCORING – AGAINST
      {
        label: "Most Points Against",
        group: "Scoring (Points Against)",
        sortKey: "pointsAgainst",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "pointsAgainst", label: "Pts Against", format: "points", polarity: "negativePrimary" },
          { key: "games", label: "G", format: "integer" },
          { key: "ppmAgainst", label: "PPM Against", format: "ppm", polarity: "negative" }
        ]
      },
      {
        label: "Fewest Points Against",
        group: "Scoring (Points Against)",
        sortKey: "pointsAgainst",
        sortDir: "asc",
        type: "aggregate",
        columns: [
          { key: "pointsAgainst", label: "Pts Against", format: "points", polarity: "positivePrimary" },
          { key: "games", label: "G", format: "integer" },
          { key: "ppmAgainst", label: "PPM Against", format: "ppm", polarity: "positive" }
        ]
      },
      {
        label: "Highest PPM Against",
        group: "Scoring (Points Against)",
        sortKey: "ppmAgainst",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "ppmAgainst", label: "PPM Against", format: "ppm", polarity: "negativePrimary" },
          { key: "pointsAgainst", label: "Pts Against", format: "points" },
          { key: "games", label: "G", format: "integer" }
        ]
      },
      {
        label: "Lowest PPM Against",
        group: "Scoring (Points Against)",
        sortKey: "ppmAgainst",
        sortDir: "asc",
        type: "aggregate",
        columns: [
          { key: "ppmAgainst", label: "PPM Against", format: "ppm", polarity: "positivePrimary" },
          { key: "pointsAgainst", label: "Pts Against", format: "points" },
          { key: "games", label: "G", format: "integer" }
        ]
      },

      // RESULTS – WIN %
      {
        label: "Highest Winning Percentage",
        group: "Results (Win % & Record)",
        sortKey: "winPct",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "winPct", label: "Win %", format: "percent", polarity: "positivePrimary" },
          { key: "record", label: "Record", format: "record" },
          { key: "games", label: "G", format: "integer" }
        ]
      },
      {
        label: "Lowest Winning Percentage",
        group: "Results (Win % & Record)",
        sortKey: "winPct",
        sortDir: "asc",
        type: "aggregate",
        columns: [
          { key: "winPct", label: "Win %", format: "percent", polarity: "negativePrimary" },
          { key: "record", label: "Record", format: "record" },
          { key: "games", label: "G", format: "integer" }
        ]
      },

      // RESULTS – WINS & LOSSES
      {
        label: "Most Wins",
        group: "Results (Wins & Losses)",
        sortKey: "winsInt",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "winsInt", label: "W", format: "integer", polarity: "positivePrimary" },
          { key: "lossesInt", label: "L", format: "integer" },
          { key: "tiesInt", label: "T", format: "integer" },
          { key: "winPct", label: "Win %", format: "percent" },
          { key: "games", label: "G", format: "integer" }
        ]
      },
      {
        label: "Most Losses",
        group: "Results (Wins & Losses)",
        sortKey: "lossesInt",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "lossesInt", label: "L", format: "integer", polarity: "negativePrimary" },
          { key: "winsInt", label: "W", format: "integer" },
          { key: "tiesInt", label: "T", format: "integer" },
          { key: "winPct", label: "Win %", format: "percent" },
          { key: "games", label: "G", format: "integer" }
        ]
      },

      // WEEKLY HIGHS
      {
        label: "Most Weekly High Scores",
        group: "Weekly Dominance",
        sortKey: "weeklyHighCount",
        sortDir: "desc",
        type: "aggregate",
        columns: [
          { key: "weeklyHighCount", label: "Weekly Highs", format: "integer", polarity: "positivePrimary" },
          { key: "weeklyHighRate", label: "Weekly High Rate", format: "percent" },
          { key: "games", label: "G", format: "integer" }
        ]
      },
      {
        label: "Fewest Weekly High Scores",
        group: "Weekly Dominance",
        sortKey: "weeklyHighCount",
        sortDir: "asc",
        type: "aggregate",
        columns: [
          { key: "weeklyHighCount", label: "Weekly Highs", format: "integer", polarity: "negativePrimary" },
          { key: "weeklyHighRate", label: "Weekly High Rate", format: "percent" },
          { key: "games", label: "G", format: "integer" }
        ]
      },

      // STREAKS
      {
        label: "Longest Winning Streak",
        group: "Streaks",
        type: "streak",
        streakType: "win"
      },
      {
        label: "Longest Losing Streak",
        group: "Streaks",
        type: "streak",
        streakType: "lose"
      }
    ];

    const CATEGORY_BY_LABEL = CATEGORY_DEFS.reduce((acc, def) => {
      acc[def.label] = def;
      return acc;
    }, {});

    // === Helpers: scope, aggregation, streaks ===

    function isPlayoffGame(m) {
      return m.playoffs && m.playoffs !== "N/A";
    }

    function getScopesForMatch(m) {
      const scopes = new Set();
      scopes.add("All Matchups");
      if (isPlayoffGame(m)) {
        scopes.add("Playoff Matchups");
      } else {
        scopes.add("Regular Season Matchups");
      }
      return scopes;
    }

    function buildAggregates(matches) {
      const result = {};
      const weekScoresByScope = {};
      const seqByScope = {};

      MATCHUP_TYPES.forEach(scope => {
        result[scope] = {};
        weekScoresByScope[scope] = {};
        seqByScope[scope] = {};
        streaksByScope[scope] = { win: [], lose: [] };
      });

      matches.forEach(m => {
        const scopes = getScopesForMatch(m);
        const participants = [
          { manager: m.manager1, scored: m.score1, allowed: m.score2 },
          { manager: m.manager2, scored: m.score2, allowed: m.score1 }
        ];

        scopes.forEach(scope => {
          const managersStats = result[scope];
          const weekScores = weekScoresByScope[scope];
          const seqMap = seqByScope[scope];

          const weekKey = `${m.year}-${m.week}`;
          if (!weekScores[weekKey]) weekScores[weekKey] = [];

          participants.forEach(p => {
            weekScores[weekKey].push({ manager: p.manager, score: p.scored });

            if (!managersStats[p.manager]) {
              managersStats[p.manager] = {
                manager: p.manager,
                games: 0,
                pointsFor: 0,
                pointsAgainst: 0,
                winsInt: 0,
                lossesInt: 0,
                tiesInt: 0,
                weeklyHighCount: 0,
                longestWinStreak: 0,
                longestLoseStreak: 0,
                lastYear: null,
                lastWeek: null
              };
              seqMap[p.manager] = [];
            }

            const s = managersStats[p.manager];
            s.games += 1;
            s.pointsFor += p.scored;
            s.pointsAgainst += p.allowed;

            let isWin = false;
            let isLoss = false;

            if (p.scored > p.allowed) {
              s.winsInt += 1;
              isWin = true;
            } else if (p.scored < p.allowed) {
              s.lossesInt += 1;
              isLoss = true;
            } else {
              s.tiesInt += 1;
            }

            if (
              s.lastYear === null ||
              m.year > s.lastYear ||
              (m.year === s.lastYear && m.week > s.lastWeek)
            ) {
              s.lastYear = m.year;
              s.lastWeek = m.week;
            }

            seqMap[p.manager].push({
              year: m.year,
              week: m.week,
              isWin,
              isLoss
            });
          });
        });
      });

      // Weekly highs & streaks
      MATCHUP_TYPES.forEach(scope => {
        const managersStats = result[scope];
        const weekScores = weekScoresByScope[scope];
        const seqMap = seqByScope[scope];
        const scopeStreaks = streaksByScope[scope];

        // Weekly highs
        Object.keys(weekScores).forEach(weekKey => {
          const arr = weekScores[weekKey];
          if (!arr || arr.length === 0) return;
          const maxScore = Math.max(...arr.map(x => x.score));
          arr.forEach(x => {
            if (x.score === maxScore && managersStats[x.manager]) {
              managersStats[x.manager].weeklyHighCount += 1;
            }
          });
        });

        // Streaks
        Object.keys(seqMap).forEach(manager => {
          const seq = seqMap[manager].slice().sort((a, b) => {
            if (a.year !== b.year) return a.year - b.year;
            return a.week - b.week;
          });

          let winStreaks = [];
          let loseStreaks = [];

          // Win streaks
          let startIdx = null;
          for (let i = 0; i < seq.length; i++) {
            const e = seq[i];
            if (e.isWin) {
              if (startIdx === null) startIdx = i;
            } else if (startIdx !== null) {
              const endIdx = i - 1;
              const start = seq[startIdx];
              const end = seq[endIdx];
              winStreaks.push({
                manager,
                length: endIdx - startIdx + 1,
                startYear: start.year,
                startWeek: start.week,
                endYear: end.year,
                endWeek: end.week
              });
              startIdx = null;
            }
          }
          if (startIdx !== null) {
            const endIdx = seq.length - 1;
            const start = seq[startIdx];
            const end = seq[endIdx];
            winStreaks.push({
              manager,
              length: endIdx - startIdx + 1,
              startYear: start.year,
              startWeek: start.week,
              endYear: end.year,
              endWeek: end.week
            });
          }

          // Loss streaks
          startIdx = null;
          for (let i = 0; i < seq.length; i++) {
            const e = seq[i];
            if (e.isLoss) {
              if (startIdx === null) startIdx = i;
            } else if (startIdx !== null) {
              const endIdx = i - 1;
              const start = seq[startIdx];
              const end = seq[endIdx];
              loseStreaks.push({
                manager,
                length: endIdx - startIdx + 1,
                startYear: start.year,
                startWeek: start.week,
                endYear: end.year,
                endWeek: end.week
              });
              startIdx = null;
            }
          }
          if (startIdx !== null) {
            const endIdx = seq.length - 1;
            const start = seq[startIdx];
            const end = seq[endIdx];
            loseStreaks.push({
              manager,
              length: endIdx - startIdx + 1,
              startYear: start.year,
              startWeek: start.week,
              endYear: end.year,
              endWeek: end.week
            });
          }

          const longestWin = winStreaks.reduce((max, s) => Math.max(max, s.length), 0);
          const longestLose = loseStreaks.reduce((max, s) => Math.max(max, s.length), 0);
          managersStats[manager].longestWinStreak = longestWin;
          managersStats[manager].longestLoseStreak = longestLose;

          scopeStreaks.win.push(...winStreaks);
          scopeStreaks.lose.push(...loseStreaks);
        });
      });

      return result;
    }

    // === Metric & formatting helpers ===

    function getMetric(stats, key) {
      switch (key) {
        case "games": return stats.games;
        case "pointsFor": return stats.pointsFor;
        case "ppmFor": return stats.games ? stats.pointsFor / stats.games : 0;
        case "pointsAgainst": return stats.pointsAgainst;
        case "ppmAgainst": return stats.games ? stats.pointsAgainst / stats.games : 0;
        case "winsInt": return stats.winsInt;
        case "lossesInt": return stats.lossesInt;
        case "tiesInt": return stats.tiesInt;
        case "winPct":
          return stats.games
            ? (stats.winsInt + 0.5 * stats.tiesInt) / stats.games
            : 0;
        case "weeklyHighCount": return stats.weeklyHighCount;
        case "weeklyHighRate":
          return stats.games ? stats.weeklyHighCount / stats.games : 0;
        default:
          return stats[key];
      }
    }

    function formatValue(value, format, stats) {
      if (format === "record") {
        const w = stats.winsInt || 0;
        const l = stats.lossesInt || 0;
        const t = stats.tiesInt || 0;
        return t ? `${w}-${l}-${t}` : `${w}-${l}`;
      }

      if (value === null || value === undefined || Number.isNaN(value)) return "-";

      switch (format) {
        case "percent":
          return (value * 100).toFixed(2);
        case "ppm":
          return value.toFixed(1);
        case "points":
          return value.toLocaleString("en-US", {
            minimumFractionDigits: 1,
            maximumFractionDigits: 1
          });
        case "integer":
        default:
          return value.toLocaleString("en-US", { maximumFractionDigits: 0 });
      }
    }

    // === Dropdowns ===

    function populateDropdowns() {
      const matchupSelect = document.getElementById("matchupTypeSelect");
      const categorySelect = document.getElementById("categorySelect");

      MATCHUP_TYPES.forEach(type => {
        const opt = document.createElement("option");
        opt.value = type;
        opt.textContent = type;
        matchupSelect.appendChild(opt);
      });

      const groups = [...new Set(CATEGORY_DEFS.map(c => c.group))];
      groups.forEach(groupLabel => {
        const group = document.createElement("optgroup");
        group.label = groupLabel;
        CATEGORY_DEFS.filter(c => c.group === groupLabel).forEach(def => {
          const opt = document.createElement("option");
          opt.value = def.label;
          opt.textContent = def.label;
          group.appendChild(opt);
        });
        categorySelect.appendChild(group);
      });

      matchupSelect.value = "All Matchups";
      categorySelect.value = "Most Points For";
    }

    // === Sorting state ===
    let currentSort = {
      type: "aggregate",
      matchupType: null,
      categoryLabel: null,
      columnKey: null,
      direction: null
    };

    // === Aggregate leaderboard render ===

    function renderAggregateLeaderboard(matchupType, def) {
      const headerRow = document.getElementById("headerRow");
      const tbody = document.getElementById("leaderboardBody");
      const noDataMessage = document.getElementById("noDataMessage");

      const statsMap = aggregatesByScope[matchupType] || {};
      const allStats = Object.values(statsMap);

      if (!allStats.length) {
        headerRow.innerHTML = "";
        tbody.innerHTML = "";
        noDataMessage.style.display = "block";
        noDataMessage.firstElementChild.textContent = "Note · No data for this combination yet";
        return;
      }

      // ranking (ties share rank; recency tiebreak)
      const rankingOrder = allStats.slice().sort((a, b) => {
        const av = getMetric(a, def.sortKey);
        const bv = getMetric(b, def.sortKey);
        if (av !== bv) return def.sortDir === "asc" ? av - bv : bv - av;
        if (a.lastYear !== b.lastYear) return b.lastYear - a.lastYear;
        if (a.lastWeek !== b.lastWeek) return b.lastWeek - a.lastWeek;
        return a.manager.localeCompare(b.manager);
      });

      const rankMap = {};
      let prevValue = null;
      let currentRank = 0;
      rankingOrder.forEach((stats, index) => {
        const v = getMetric(stats, def.sortKey);
        if (prevValue === null || v !== prevValue) {
          currentRank = index + 1;
          prevValue = v;
        }
        rankMap[stats.manager] = currentRank;
      });

      let columnKey = def.sortKey;
      let direction = def.sortDir;
      if (
        currentSort.matchupType === matchupType &&
        currentSort.categoryLabel === def.label &&
        currentSort.type === "aggregate" &&
        currentSort.columnKey
      ) {
        columnKey = currentSort.columnKey;
        direction = currentSort.direction || "desc";
      }

      const sorted = allStats.slice().sort((a, b) => {
        if (columnKey === "manager") {
          const cmp = a.manager.localeCompare(b.manager);
          return direction === "asc" ? cmp : -cmp;
        } else {
          const av = getMetric(a, columnKey);
          const bv = getMetric(b, columnKey);
          if (av === bv) {
            if (a.lastYear !== b.lastYear) return b.lastYear - a.lastYear;
            if (a.lastWeek !== b.lastWeek) return b.lastWeek - a.lastWeek;
            return a.manager.localeCompare(b.manager);
          }
          return direction === "asc" ? av - bv : bv - av;
        }
      });

      headerRow.innerHTML = "";
      const rankTh = document.createElement("th");
      rankTh.className = "th-left";
      rankTh.textContent = "Rank";
      rankTh.dataset.colKey = "rank";
      const managerTh = document.createElement("th");
      managerTh.className = "th-left";
      managerTh.textContent = "Manager";
      managerTh.dataset.colKey = "manager";
      headerRow.appendChild(rankTh);
      headerRow.appendChild(managerTh);

      def.columns.forEach(col => {
        const th = document.createElement("th");
        th.textContent = col.label;
        th.className = "th-right";
        th.dataset.colKey = col.key === "record" ? "winPct" : col.key;
        headerRow.appendChild(th);
      });

      tbody.innerHTML = "";
      sorted.forEach(stats => {
        const tr = document.createElement("tr");
        if (rankMap[stats.manager] === 1) tr.classList.add("top-rank");

        const rankTd = document.createElement("td");
        rankTd.className = "rank-cell";
        rankTd.textContent = rankMap[stats.manager];

        const managerTd = document.createElement("td");
        managerTd.className = "manager-cell";
        managerTd.textContent = stats.manager;

        tr.appendChild(rankTd);
        tr.appendChild(managerTd);

        def.columns.forEach(col => {
          const td = document.createElement("td");
          td.className = "stat-cell";
          const metricKey = col.key === "record" ? "record" : col.key;
          const rawValue =
            metricKey === "record" ? null : getMetric(stats, metricKey);
          const displayValue =
            metricKey === "record"
              ? formatValue(null, "record", stats)
              : formatValue(rawValue, col.format, stats);

          if (col.polarity === "positivePrimary") td.classList.add("value-positive");
          if (col.polarity === "negativePrimary") td.classList.add("value-negative");

          td.textContent = displayValue;
          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      noDataMessage.style.display = "none";

      headerRow.onclick = (e) => {
        const th = e.target.closest("th");
        if (!th) return;
        const colKey = th.dataset.colKey;
        if (!colKey) return;

        let newColumnKey;
        if (colKey === "rank") newColumnKey = def.sortKey;
        else if (colKey === "manager") newColumnKey = "manager";
        else newColumnKey = colKey;

        let newDir = "desc";
        if (
          currentSort.matchupType === matchupType &&
          currentSort.categoryLabel === def.label &&
          currentSort.type === "aggregate" &&
          currentSort.columnKey === newColumnKey
        ) {
          newDir = currentSort.direction === "asc" ? "desc" : "asc";
        } else {
          if (newColumnKey === "manager") newDir = "asc";
          else if (newColumnKey === def.sortKey) newDir = def.sortDir;
          else newDir = "desc";
        }

        currentSort = {
          type: "aggregate",
          matchupType,
          categoryLabel: def.label,
          columnKey: newColumnKey,
          direction: newDir
        };

        renderLeaderboard(matchupType, def.label);
      };
    }

    // === Streak leaderboard ===

    function renderStreakLeaderboard(matchupType, def) {
      const headerRow = document.getElementById("headerRow");
      const tbody = document.getElementById("leaderboardBody");
      const noDataMessage = document.getElementById("noDataMessage");

      const scopeStreaks = streaksByScope[matchupType] || { win: [], lose: [] };
      const allRaw = def.streakType === "win" ? scopeStreaks.win : scopeStreaks.lose;

      let raw = allRaw;

      // playoff caps: wins >=3, losses >=2
      if (matchupType === "Playoff Matchups") {
        if (def.streakType === "win") {
          raw = allRaw.filter(s => s.length >= 3);
        } else {
          raw = allRaw.filter(s => s.length >= 2);
        }
      }

      // regular season longest winning streak: min 8
      if (matchupType === "Regular Season Matchups" && def.streakType === "win") {
        raw = raw.filter(s => s.length >= 8);
      }

      if (!raw || raw.length === 0) {
        headerRow.innerHTML = "";
        tbody.innerHTML = "";
        noDataMessage.style.display = "block";
        noDataMessage.firstElementChild.textContent = "Note · No streak data for this combination yet";
        return;
      }

      const rowsWithLabels = raw.map(s => {
        let spanLabel;
        if (s.startYear === s.endYear) {
          if (s.startWeek === s.endWeek) {
            spanLabel = `${s.startYear} Wk ${s.startWeek}`;
          } else {
            spanLabel = `${s.startYear} Wk ${s.startWeek}–Wk ${s.endWeek}`;
          }
        } else {
          spanLabel = `${s.startYear} Wk ${s.startWeek} → ${s.endYear} Wk ${s.endWeek}`;
        }

        return { ...s, spanLabel };
      });

      const rankingOrder = rowsWithLabels.slice().sort((a, b) => {
        if (b.length !== a.length) return b.length - a.length;
        if (b.endYear !== a.endYear) return b.endYear - a.endYear;
        if (b.endWeek !== a.endWeek) return b.endWeek - a.endWeek;
        return a.manager.localeCompare(b.manager);
      });

      const rankMap = new Map();
      let prevLen = null;
      let currentRank = 0;
      rankingOrder.forEach((s, index) => {
        const len = s.length;
        if (prevLen === null || len !== prevLen) {
          currentRank = index + 1;
          prevLen = len;
        }
        rankMap.set(s, currentRank);
      });

      let columnKey = "length";
      let direction = "desc";
      if (
        currentSort.matchupType === matchupType &&
        currentSort.categoryLabel === def.label &&
        currentSort.type === "streak" &&
        currentSort.columnKey
      ) {
        columnKey = currentSort.columnKey;
        direction = currentSort.direction || "desc";
      }

      const sorted = rowsWithLabels.slice().sort((a, b) => {
        if (columnKey === "manager") {
          const cmp = a.manager.localeCompare(b.manager);
          return direction === "asc" ? cmp : -cmp;
        } else if (columnKey === "spanLabel") {
          const cmp = a.spanLabel.localeCompare(b.spanLabel);
          return direction === "asc" ? cmp : -cmp;
        } else {
          const av = a.length;
          const bv = b.length;
          if (av === bv) {
            if (b.endYear !== a.endYear) return b.endYear - a.endYear;
            if (b.endWeek !== a.endWeek) return b.endWeek - a.endWeek;
            return a.manager.localeCompare(b.manager);
          }
          return direction === "asc" ? av - bv : bv - av;
        }
      });

      const top = sorted.slice(0, 10);

      headerRow.innerHTML = "";
      const rankTh = document.createElement("th");
      rankTh.className = "th-left";
      rankTh.textContent = "Rank";
      rankTh.dataset.colKey = "rank";
      const managerTh = document.createElement("th");
      managerTh.className = "th-left";
      managerTh.textContent = "Manager";
      managerTh.dataset.colKey = "manager";
      const lenTh = document.createElement("th");
      lenTh.className = "th-right";
      lenTh.textContent = "Games";
      lenTh.dataset.colKey = "length";
      const spanTh = document.createElement("th");
      spanTh.className = "th-right";
      spanTh.textContent = "Span";
      spanTh.dataset.colKey = "spanLabel";

      headerRow.appendChild(rankTh);
      headerRow.appendChild(managerTh);
      headerRow.appendChild(lenTh);
      headerRow.appendChild(spanTh);

      tbody.innerHTML = "";
      top.forEach(s => {
        const tr = document.createElement("tr");
        if (rankMap.get(s) === 1) tr.classList.add("top-rank");

        const rankTd = document.createElement("td");
        rankTd.className = "rank-cell";
        rankTd.textContent = rankMap.get(s);

        const managerTd = document.createElement("td");
        managerTd.className = "manager-cell";
        managerTd.textContent = s.manager;

        const lenTd = document.createElement("td");
        lenTd.className = "stat-cell " + (def.streakType === "win" ? "value-positive" : "value-negative");
        lenTd.textContent = s.length.toString();

        const spanTd = document.createElement("td");
        spanTd.className = "stat-cell";
        spanTd.textContent = s.spanLabel;

        tr.appendChild(rankTd);
        tr.appendChild(managerTd);
        tr.appendChild(lenTd);
        tr.appendChild(spanTd);

        tbody.appendChild(tr);
      });

      noDataMessage.style.display = "none";
      noDataMessage.firstElementChild.textContent = "Note · No data for this combination yet";

      headerRow.onclick = (e) => {
        const th = e.target.closest("th");
        if (!th) return;
        const colKey = th.dataset.colKey;
        if (!colKey) return;

        let newColumnKey;
        if (colKey === "rank") newColumnKey = "length";
        else newColumnKey = colKey;

        let newDir = "desc";
        if (
          currentSort.matchupType === matchupType &&
          currentSort.categoryLabel === def.label &&
          currentSort.type === "streak" &&
          currentSort.columnKey === newColumnKey
        ) {
          newDir = currentSort.direction === "asc" ? "desc" : "asc";
        } else {
          if (newColumnKey === "manager" || newColumnKey === "spanLabel") {
            newDir = "asc";
          } else {
            newDir = "desc";
          }
        }

        currentSort = {
          type: "streak",
          matchupType,
          categoryLabel: def.label,
          columnKey: newColumnKey,
          direction: newDir
        };

        renderLeaderboard(matchupType, def.label);
      };
    }

    // === Main render ===

    function renderLeaderboard(matchupType, categoryLabel) {
      const titleEl = document.getElementById("leaderboardTitle");
      const subtitleEl = document.getElementById("leaderboardSubtitle");
      const pillLabel = document.getElementById("pillLabel");
      const noDataMessage = document.getElementById("noDataMessage");
      const headerRow = document.getElementById("headerRow");
      const tbody = document.getElementById("leaderboardBody");

      const def = CATEGORY_BY_LABEL[categoryLabel];
      if (!def) return;

      titleEl.textContent = `${def.label} · ${matchupType}`;
      pillLabel.textContent = matchupType;

      // Weekly highs not valid for playoffs
      if (
        matchupType === "Playoff Matchups" &&
        def.group === "Weekly Dominance"
      ) {
        headerRow.innerHTML = "";
        tbody.innerHTML = "";
        noDataMessage.style.display = "block";
        noDataMessage.firstElementChild.textContent =
          "Note · Weekly high scores are only tracked for Regular Season matchups.";
        subtitleEl.textContent =
          "This stat is only computed for regular season games.";
        return;
      }

      if (def.type === "streak") {
        subtitleEl.textContent =
          "Career streaks with exact start–end span";
        renderStreakLeaderboard(matchupType, def);
      } else {
        subtitleEl.textContent =
          "Career leaders across all eligible matchups with context";
        renderAggregateLeaderboard(matchupType, def);
      }
    }

    // === Load JSON & init ===

    async function loadMatchups() {
      try {
        const res = await fetch("league-scores.json");
        if (!res.ok) {
          console.error("Failed to load league-scores.json:", res.status, res.statusText);
          return [];
        }
        return await res.json();
      } catch (err) {
        console.error("Error loading league-scores.json", err);
        return [];
      }
    }

    document.addEventListener("DOMContentLoaded", async () => {
      populateDropdowns();

      rawMatchups = await loadMatchups();
      aggregatesByScope = buildAggregates(rawMatchups);

      const matchupSelect = document.getElementById("matchupTypeSelect");
      const categorySelect = document.getElementById("categorySelect");

      function update() {
        const matchupType = matchupSelect.value;
        const categoryLabel = categorySelect.value;
        const def = CATEGORY_BY_LABEL[categoryLabel];
        if (!def) return;

        if (def.type === "streak") {
          currentSort = {
            type: "streak",
            matchupType,
            categoryLabel,
            columnKey: "length",
            direction: "desc"
          };
        } else {
          currentSort = {
            type: "aggregate",
            matchupType,
            categoryLabel,
            columnKey: def.sortKey,
            direction: def.sortDir
          };
        }

        renderLeaderboard(matchupType, categoryLabel);
      }

      matchupSelect.addEventListener("change", update);
      categorySelect.addEventListener("change", update);

      update();
    });
  </script>
</body>
</html>
