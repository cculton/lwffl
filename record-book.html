<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="style.css">
  <meta charset="UTF-8" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Record Book – LWFFL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    :root{
      --bg-main:#020617;
      --card-bg:#020617;
      --accent:#38bdf8;
      --border-subtle:#1f2937;
      --text-main:#e5e7eb;
      --text-muted:#9ca3af;
      --text-soft:#6b7280;
      --positive:#22c55e;
      --negative:#ef4444;
      --warning:#f59e0b;
    }

    body{
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 35%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 24px 16px;
    }

    .shell{ max-width: 1100px; margin: 0 auto; }
    .container{
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), transparent 55%),
        radial-gradient(circle at bottom right, rgba(59, 130, 246, 0.18), transparent 55%),
        var(--card-bg);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow: 0 40px 80px rgba(0,0,0,0.8), 0 0 0 1px rgba(15,23,42,0.9);
      padding: 28px 24px 28px;
      backdrop-filter: blur(14px);
    }

    .header{ text-align:center; margin-bottom: 16px; }
    .header h1{
      font-size: 2rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-weight: 700;
      margin-bottom: 6px;
      color:#f9fafb;
    }
    .header p{
      color: var(--text-soft);
      font-size: 0.9rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    /* Scope tabs */
    .scope-tabs{
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      margin: 18px 0 18px;
    }
    .scope-btn{
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.7);
      color: var(--text-muted);
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      cursor: pointer;
      user-select:none;
      transition: transform .08s ease, box-shadow .15s ease, border-color .15s ease, color .15s ease;
    }
    .scope-btn:hover{ transform: translateY(-1px); }
    .scope-btn[aria-selected="true"]{
      color:#f9fafb;
      border-color: rgba(56,189,248,0.85);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.35), 0 0 12px rgba(56,189,248,0.25);
      background: rgba(15,23,42,0.92);
    }

    .controls{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:16px;
      margin-bottom: 18px;
      align-items:end;
    }
    .control-group{ display:flex; flex-direction:column; }

    label{
      margin-bottom:6px;
      color: var(--text-muted);
      font-weight:600;
      font-size:0.8rem;
      letter-spacing:0.14em;
      text-transform:uppercase;
    }

    select{
      appearance:none; -webkit-appearance:none; -moz-appearance:none;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(75,85,99,0.9);
      background-color: #0b1120;
      color:#f9fafb;
      font-size:0.95rem;
      font-weight:500;
      line-height:1.4;
      outline:none;
      cursor:pointer;
      box-shadow: 0 1px 3px rgba(15,23,42,0.7);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    select:focus{
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.7), 0 0 12px rgba(56,189,248,0.45);
    }
    optgroup{
      background-color:#020617;
      color: var(--text-soft);
      font-style:normal;
      font-size:0.8rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    select option{ background-color:#020617; color:#f9fafb; }

    .hint{
      font-size:0.8rem;
      color: var(--text-soft);
      text-align:right;
      line-height:1.35;
    }

    .leaderboard-card{
      background: radial-gradient(circle at top, rgba(15,23,42,0.97), rgba(15,23,42,0.99));
      border-radius: 14px;
      border: 1px solid rgba(31,41,55,0.95);
      box-shadow: 0 20px 40px rgba(15,23,42,0.95), 0 0 0 1px rgba(15,23,42,0.95);
      padding: 18px 16px 16px;
    }

    .leaderboard-header{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      margin-bottom: 12px;
      gap: 12px;
      flex-wrap:wrap;
    }

    .leaderboard-title{
      font-size:1.1rem;
      font-weight:600;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:#e5e7eb;
      margin-bottom: 6px;
    }
    .leaderboard-subtitle{
      font-size:0.8rem;
      color: var(--text-soft);
      letter-spacing:0.16em;
      text-transform:uppercase;
      line-height: 1.3;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.9);
      font-size:0.72rem;
      text-transform:uppercase;
      letter-spacing:0.12em;
      color: var(--text-muted);
      white-space:nowrap;
    }
    .pill-dot{ width:6px; height:6px; border-radius:999px; background: var(--accent); opacity:0.8; }

    /* Table wrapper = mobile friendly */
    .table-wrap{
      width:100%;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      border-radius: 10px;
    }

    .leaderboard-table{
      width:100%;
      border-collapse: collapse;
      font-size:0.9rem;
      min-width: 600px; /* Ensured min-width for mobile responsiveness */
      border-radius:10px;
      overflow:hidden;
    }
    .leaderboard-table thead{ background: linear-gradient(90deg, #020617, #020617); }
    .leaderboard-table th{
      padding: 8px 10px;
      font-size:0.78rem;
      text-transform:uppercase;
      letter-spacing:0.18em;
      color:#9ca3af;
      border-bottom: 1px solid rgba(55,65,81,0.9);
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
    }
    .th-left{ text-align:left; }
    .th-right{ text-align:right; }

    .leaderboard-table tbody tr{ transition: background 0.15s ease, transform 0.08s ease; }
    .leaderboard-table tbody tr:nth-child(odd){ background:#020617; }
    .leaderboard-table tbody tr:nth-child(even){ background:#020617; }
    .leaderboard-table tbody tr:hover{ background: rgba(15,23,42,0.98); transform: translateY(-1px); }

    .leaderboard-table td{
      padding: 9px 10px;
      border-bottom: 1px solid rgba(31,41,55,0.96);
      color: var(--text-main);
    }
    .leaderboard-table tbody tr:last-child td{ border-bottom:none; }

    .rank-cell{ font-weight:600; color: var(--text-muted); width:60px; text-align:left; }
    .manager-cell{ font-weight:500; white-space:nowrap; text-align:left; }
    .stat-cell{ text-align:right; font-variant-numeric: tabular-nums; }

    .value-positive{ color: var(--positive); font-weight:600; }
    .value-negative{ color: var(--negative); font-weight:600; }
    .top-rank{
      background: radial-gradient(circle at left, rgba(56,189,248,0.16), transparent 60%);
      box-shadow: inset 2px 0 0 rgba(56,189,248,0.8);
    }

    .no-data{
      font-size:0.9rem;
      color: var(--text-soft);
      padding: 14px 8px 4px;
    }
    .no-data span{
      border-radius:999px;
      border: 1px dashed rgba(75,85,99,0.9);
      padding: 6px 10px;
      display:inline-flex;
      gap:6px;
      align-items:center;
      background: rgba(15,23,42,0.85);
      font-size:0.78rem;
      text-transform:uppercase;
      letter-spacing:0.14em;
      line-height:1.25;
    }

    .footer-note{
      margin-top: 14px;
      font-size: 0.75rem;
      color: var(--text-soft);
      text-align:right;
    }

    @media (max-width: 900px){
      .controls{ grid-template-columns: 1fr; }
      .hint{ text-align:left; }
    }
    @media (max-width: 600px){
      .container{ padding: 22px 14px 20px; }
      .header h1{ font-size: 1.4rem; }
      .leaderboard-title{ font-size: 1rem; }
      .leaderboard-table th, .leaderboard-table td{ padding: 7px 6px; }
      .leaderboard-table{ min-width: 520px; }
    }
  
    .pagination{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:wrap;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(31,41,55,0.75);
    }
    .page-btn{
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.85);
      color: #f9fafb;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.82rem;
      font-weight: 650;
      letter-spacing: 0.06em;
      cursor:pointer;
      transition: transform .08s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .page-btn:disabled{
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .page-btn:hover:not(:disabled){
      transform: translateY(-1px);
      border-color: rgba(56,189,248,0.7);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.25);
    }
    .page-meta{
      font-size: 0.78rem;
      color: var(--text-muted);
      letter-spacing: 0.14em;
      text-transform: uppercase;
      white-space:nowrap;
    }
    .page-status{
      font-size: 0.78rem;
      color: var(--text-soft);
      letter-spacing: 0.06em;
      white-space:nowrap;
    }

    /* Featured stat column highlight */
    .featured-col{
      background: rgba(56, 189, 248, 0.08);
    }
    .leaderboard-table thead th.featured-col{
      background: rgba(56, 189, 248, 0.12);
    }

    /* Global: left-align all table headers/cells across scopes */
    .leaderboard-table th,
    .leaderboard-table td{
      text-align: left !important;
    }
    .stat-cell{
      text-align: left !important;
      font-variant-numeric: tabular-nums;
    }

  </style>
</head>

<body>
  <div id="nav-placeholder"></div>
  <div id="nav-placeholder"></div>
  <div class="shell">
    <div class="container">
      <header class="header">
        <h1>Record Book</h1>
        <p>Legion of Whom Fantasy Football League  · 2014–Present</p>
      </header>

      <nav class="scope-tabs" aria-label="Scope">
        <button class="scope-btn" data-scope="Career" aria-selected="true" type="button">Career</button>
        <button class="scope-btn" data-scope="Season" aria-selected="false" type="button">Season</button>
        <button class="scope-btn" data-scope="Weekly" aria-selected="false" type="button">Week</button>
      </nav>

      <section class="controls" aria-label="Controls">
        <div class="control-group">
          <label for="matchupTypeSelect">Matchup Type</label>
          <select id="matchupTypeSelect"></select>
        </div>

        <div class="control-group">
          <label for="categorySelect">Stat Category</label>
          <select id="categorySelect"></select>
        </div>

        <div class="control-group">
          <div class="hint" id="scopeHint"></div>
        </div>
      </section>

      <section class="leaderboard-card">
        <div class="leaderboard-header">
          <div>
            <div class="leaderboard-title" id="leaderboardTitle">Career Leaders</div>
            <div class="leaderboard-subtitle" id="leaderboardSubtitle"></div>
          </div>
          <div class="pill" title="Scope · Matchup Type">
            <span class="pill-dot"></span>
            <span id="pillLabel">Career · —</span>
          </div>
        </div>

        <div class="table-wrap">
          <table class="leaderboard-table" aria-live="polite">
            <thead><tr id="headerRow"></tr></thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>

        <div class="pagination" id="pagination" aria-label="Pagination">
          <button class="page-btn" id="prevPage" type="button">Prev</button>
          <div class="page-meta" id="pageMeta">Page 1 of 1</div>
          <button class="page-btn" id="nextPage" type="button">Next</button>
          <div class="page-status" id="pageStatus">Showing 0–0 of 0</div>
        </div>

        <div class="no-data" id="noDataMessage">
          <span>Select a matchup type and stat category to see leaderboard data.</span>
        </div>

        <div class="footer-note">
          Data source: <strong>league-scores.json</strong> in this repo.
        </div>
      </section>
    </div>
  </div>

<script>
  // === Global containers ===
  let rawMatchups = [];
  let currentScope = "Career";

  // Career containers
  let aggregatesByScope = {};
  let streaksByScope = {};

  // Career accolades
  let seasonStatsRaw = [];
  let accoladesByMatchupType = {};

  // Season containers
  let seasonAggByMatchupType = {};

  // Weekly containers
  let weeklyRowsByMatchupType = {};

  // UPDATED Matchup Types
  const MATCHUP_TYPES = ["Regular Season + Playoffs", "Regular Season Only", "Playoffs Only"];

  // ---------------------------
  // Category definitions
  // ---------------------------

  // CAREER
  const CAREER_CATEGORY_DEFS = [
    // SCORING – FOR
    { label:"Most Points For", group:"Scoring (Points For)", sortKey:"pointsFor", sortDir:"desc", type:"aggregate",
      columns:[ {key:"pointsFor",label:"PF",format:"points",polarity:"positivePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmFor",label:"PPM",format:"ppm",polarity:"positive"} ]},
    { label:"Fewest Points For", group:"Scoring (Points For)", sortKey:"pointsFor", sortDir:"asc", type:"aggregate",
      columns:[ {key:"pointsFor",label:"PF",format:"points",polarity:"negativePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmFor",label:"PPM",format:"ppm",polarity:"negative"} ]},
    { label:"Highest Points Per Matchup (PPM)", group:"Scoring (Points For)", sortKey:"ppmFor", sortDir:"desc", type:"aggregate",
      columns:[ {key:"ppmFor",label:"PPM",format:"ppm",polarity:"positivePrimary"},
                {key:"pointsFor",label:"PF",format:"points"},
                {key:"games",label:"M",format:"integer"} ]},
    { label:"Lowest Points Per Matchup (PPM)", group:"Scoring (Points For)", sortKey:"ppmFor", sortDir:"asc", type:"aggregate",
      columns:[ {key:"ppmFor",label:"PPM",format:"ppm",polarity:"negativePrimary"},
                {key:"pointsFor",label:"PF",format:"points"},
                {key:"games",label:"M",format:"integer"} ]},

    // SCORING – AGAINST
    { label:"Most Points Against", group:"Scoring (Points Against)", sortKey:"pointsAgainst", sortDir:"desc", type:"aggregate",
      columns:[ {key:"pointsAgainst",label:"PA",format:"points",polarity:"negativePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmAgainst",label:"PAPM",format:"ppm",polarity:"negative"} ]},
    { label:"Fewest Points Against", group:"Scoring (Points Against)", sortKey:"pointsAgainst", sortDir:"asc", type:"aggregate",
      columns:[ {key:"pointsAgainst",label:"PA",format:"points",polarity:"positivePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmAgainst",label:"PAPM",format:"ppm",polarity:"positive"} ]},
    { label:"Highest Points Against Per Matchup (PAPM)", group:"Scoring (Points Against)", sortKey:"ppmAgainst", sortDir:"desc", type:"aggregate",
      columns:[ {key:"ppmAgainst",label:"PAPM",format:"ppm",polarity:"negativePrimary"},
                {key:"pointsAgainst",label:"PA",format:"points"},
                {key:"games",label:"M",format:"integer"} ]},
    { label:"Lowest Points Against Per Matchup (PAPM)", group:"Scoring (Points Against)", sortKey:"ppmAgainst", sortDir:"asc", type:"aggregate",
      columns:[ {key:"ppmAgainst",label:"PAPM",format:"ppm",polarity:"positivePrimary"},
                {key:"pointsAgainst",label:"PA",format:"points"},
                {key:"games",label:"M",format:"integer"} ]},

    // RESULTS – WIN %
    { label:"Highest Winning Percentage", group:"Results (Win % & Record)", sortKey:"winPct", sortDir:"desc", type:"aggregate",
      columns:[ {key:"winPct",label:"Win %",format:"percent",polarity:"positivePrimary"},
                {key:"record",label:"Record",format:"record"},
                {key:"games",label:"M",format:"integer"} ]},
    { label:"Lowest Winning Percentage", group:"Results (Win % & Record)", sortKey:"winPct", sortDir:"asc", type:"aggregate",
      columns:[ {key:"winPct",label:"Win %",format:"percent",polarity:"negativePrimary"},
                {key:"record",label:"Record",format:"record"},
                {key:"games",label:"M",format:"integer"} ]},

    // RESULTS – WINS & LOSSES
    { label:"Most Wins", group:"Results (Wins & Losses)", sortKey:"winsInt", sortDir:"desc", type:"aggregate",
      columns:[ {key:"winsInt",label:"W",format:"integer",polarity:"positivePrimary"},
                {key:"lossesInt",label:"L",format:"integer"},
                {key:"tiesInt",label:"T",format:"integer"},
                {key:"winPct",label:"Win %",format:"percent"},
                {key:"games",label:"M",format:"integer"} ]},
    { label:"Most Losses", group:"Results (Wins & Losses)", sortKey:"lossesInt", sortDir:"desc", type:"aggregate",
      columns:[ {key:"lossesInt",label:"L",format:"integer",polarity:"negativePrimary"},
                {key:"winsInt",label:"W",format:"integer"},
                {key:"tiesInt",label:"T",format:"integer"},
                {key:"winPct",label:"Win %",format:"percent"},
                {key:"games",label:"M",format:"integer"} ]},

    // WEEKLY HIGHS
    { label:"Most Weekly High Scores", group:"Weekly Dominance", sortKey:"weeklyHighCount", sortDir:"desc", type:"aggregate",
      columns:[ {key:"weeklyHighCount",label:"Weekly Highs",format:"integer",polarity:"positivePrimary"},
                {key:"weeklyHighRate",label:"Weekly High Rate",format:"percent"},
                {key:"games",label:"M",format:"integer"} ]},
    { label:"Fewest Weekly High Scores", group:"Weekly Dominance", sortKey:"weeklyHighCount", sortDir:"asc", type:"aggregate",
      columns:[ {key:"weeklyHighCount",label:"Weekly Highs",format:"integer",polarity:"negativePrimary"},
                {key:"weeklyHighRate",label:"Weekly High Rate",format:"percent"},
                {key:"games",label:"M",format:"integer"} ]},

    // ACCOLADES
    { label:"Championships", group:"Accolades", sortKey:"championships", sortDir:"desc", type:"accolade",
      columns:[ {key:"championships",label:"Championships",format:"integer",polarity:"positivePrimary"},
                {key:"seasons",label:"Seasons",format:"integer"} ]},
    { label:"Semifinal Appearances", group:"Accolades", sortKey:"semifinalApps", sortDir:"desc", type:"accolade",
      columns:[ {key:"semifinalApps",label:"Semifinals",format:"integer",polarity:"positivePrimary"},
                {key:"playoffApps",label:"Playoffs",format:"integer"},
                {key:"seasons",label:"Seasons",format:"integer"} ]},
    { label:"First Round Appearances", group:"Accolades", sortKey:"firstRoundApps", sortDir:"desc", type:"accolade",
      columns:[ {key:"firstRoundApps",label:"Round 1",format:"integer",polarity:"positivePrimary"},
                {key:"playoffApps",label:"Playoffs",format:"integer"},
                {key:"seasons",label:"Seasons",format:"integer"} ]},
    { label:"Total Playoff Appearances", group:"Accolades", sortKey:"playoffApps", sortDir:"desc", type:"accolade",
      columns:[ {key:"playoffApps",label:"Playoffs",format:"integer",polarity:"positivePrimary"},
                {key:"seasons",label:"Seasons",format:"integer"} ]},
    { label:"Average Final Standing Finish", group:"Accolades", sortKey:"avgFinalStanding", sortDir:"asc", type:"accolade",
      columns:[ {key:"avgFinalStanding",label:"Avg Finish",format:"standing",polarity:"positivePrimary"},
                {key:"seasons",label:"Seasons",format:"integer"} ]},
    { label:"Scoring Titles Won", group:"Accolades", sortKey:"scoringTitles", sortDir:"desc", type:"accolade",
      columns:[ {key:"scoringTitles",label:"Scoring Titles",format:"integer",polarity:"positivePrimary"},
                {key:"seasons",label:"Seasons",format:"integer"} ]},

    // STREAKS
    { label:"Longest Winning Streak", group:"Streaks", type:"streak", streakType:"win" },
    { label:"Longest Losing Streak", group:"Streaks", type:"streak", streakType:"lose" }
  ];

  // SEASON
  const SEASON_CATEGORY_DEFS = [
    { label:"Most Points For", group:"Scoring (Points For)", sortKey:"pointsFor", sortDir:"desc", type:"season",
      columns:[ {key:"pointsFor",label:"PF",format:"points",polarity:"positivePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmFor",label:"PPM",format:"ppm",polarity:"positive"},
                {key:"year",label:"Year",format:"year"} ]},
    { label:"Fewest Points For", group:"Scoring (Points For)", sortKey:"pointsFor", sortDir:"asc", type:"season",
      columns:[ {key:"pointsFor",label:"PF",format:"points",polarity:"negativePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmFor",label:"PPM",format:"ppm",polarity:"negative"},
                {key:"year",label:"Year",format:"year"} ]},
    { label:"Highest Points Per Matchup (PPM)", group:"Scoring (Points For)", sortKey:"ppmFor", sortDir:"desc", type:"season",
      columns:[ {key:"ppmFor",label:"PPM",format:"ppm",polarity:"positivePrimary"}, 
                {key:"pointsFor",label:"PF",format:"points"},
                {key:"games",label:"M",format:"integer"},
                {key:"year",label:"Year",format:"year"} ]},
    { label:"Lowest Points Per Matchup (PPM)", group:"Scoring (Points For)", sortKey:"ppmFor", sortDir:"asc", type:"season",
      columns:[ {key:"ppmFor",label:"PPM",format:"ppm",polarity:"negativePrimary"},
                {key:"pointsFor",label:"PF",format:"points"},
                {key:"games",label:"M",format:"integer"},
                {key:"year",label:"Year",format:"year"} ]},

    { label:"Most Points Against", group:"Scoring (Points Against)", sortKey:"pointsAgainst", sortDir:"desc", type:"season",
      columns:[ {key:"pointsAgainst",label:"PA",format:"points",polarity:"negativePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmAgainst",label:"PAPM",format:"ppm",polarity:"negative"},
                {key:"year",label:"Year",format:"year"} ]},
    { label:"Fewest Points Against", group:"Scoring (Points Against)", sortKey:"pointsAgainst", sortDir:"asc", type:"season",
      columns:[ {key:"pointsAgainst",label:"PA",format:"points",polarity:"positivePrimary"},
                {key:"games",label:"M",format:"integer"},
                {key:"ppmAgainst",label:"PAPM",format:"ppm",polarity:"positive"},
                {key:"year",label:"Year",format:"year"} ]},

    { label:"Highest Winning Percentage", group:"Results (Win % & Record)", sortKey:"winPct", sortDir:"desc", type:"season",
      columns:[ {key:"winPct",label:"Win %",format:"percent",polarity:"positivePrimary"},
                {key:"record",label:"Record",format:"record"},
                {key:"games",label:"M",format:"integer"},
                {key:"year",label:"Year",format:"year"} ]},
    { label:"Lowest Winning Percentage", group:"Results (Win % & Record)", sortKey:"winPct", sortDir:"asc", type:"season",
      columns:[ {key:"winPct",label:"Win %",format:"percent",polarity:"negativePrimary"},
                {key:"record",label:"Record",format:"record"},
                {key:"games",label:"M",format:"integer"},
                {key:"year",label:"Year",format:"year"} ]},

    { label:"Most Wins", group:"Results (Wins & Losses)", sortKey:"winsInt", sortDir:"desc", type:"season",
      columns:[ {key:"winsInt",label:"W",format:"integer",polarity:"positivePrimary"},
                {key:"lossesInt",label:"L",format:"integer"},
                {key:"tiesInt",label:"T",format:"integer"},
                {key:"winPct",label:"Win %",format:"percent"},
                {key:"year",label:"Year",format:"year"} ]},
    { label:"Most Losses", group:"Results (Wins & Losses)", sortKey:"lossesInt", sortDir:"desc", type:"season",
      columns:[ {key:"lossesInt",label:"L",format:"integer",polarity:"negativePrimary"},
                {key:"winsInt",label:"W",format:"integer"},
                {key:"tiesInt",label:"T",format:"integer"},
                {key:"winPct",label:"Win %",format:"percent"},
                {key:"year",label:"Year",format:"year"} ]}
  
    ,
    // STREAKS
    { label:"Longest Winning Streak", group:"Streaks", type:"seasonStreak", streakType:"win" },
    { label:"Longest Losing Streak", group:"Streaks", type:"seasonStreak", streakType:"lose" }
];

  // WEEKLY
  const WEEKLY_CATEGORY_DEFS = [
    { label:"Highest Score", group:"Scoring (Single Matchup)", sortKey:"scoreFor", sortDir:"desc", type:"weekly",
      columns:[ {key:"scoreFor",label:"Score",format:"points",polarity:"positivePrimary"},
                {key:"opponent",label:"Opponent",format:"text"},
                {key:"scoreAgainst",label:"Opp Score",format:"points"},
                {key:"yearWeek",label:"Year / Week",format:"text"} ]},
    { label:"Lowest Score", group:"Scoring (Single Matchup)", sortKey:"scoreFor", sortDir:"asc", type:"weekly",
      columns:[ {key:"scoreFor",label:"Score",format:"points",polarity:"negativePrimary"},
                {key:"opponent",label:"Opponent",format:"text"},
                {key:"scoreAgainst",label:"Opp Score",format:"points"},
                {key:"yearWeek",label:"Year / Week",format:"text"} ]},
    { label:"Biggest Margin of Victory", group:"Results (Single Matchup)", sortKey:"margin", sortDir:"desc", type:"weekly",
      // Reordered per request: MARG | Score | Opponent | Opp Score | Year/Week
      columns:[ {key:"margin",label:"MARG",format:"marg",polarity:"positivePrimary"},
                {key:"scoreFor",label:"Score",format:"points"},
                {key:"opponent",label:"Opponent",format:"text"},
                {key:"scoreAgainst",label:"Opp Score",format:"points"},
                {key:"yearWeek",label:"Year / Week",format:"text"} ]},
    { label:"Closest Win", group:"Results (Single Matchup)", sortKey:"margin", sortDir:"asc", type:"weekly",
      filterKey:"isWin", filterValue:true,
      // Reordered per request: MARG | Score | Opponent | Opp Score | Year/Week
      columns:[ {key:"margin",label:"MARG",format:"marg2",polarity:"warningPrimary"},
                {key:"scoreFor",label:"Score",format:"points"},
                {key:"opponent",label:"Opponent",format:"text"},
                {key:"scoreAgainst",label:"Opp Score",format:"points"},
                {key:"yearWeek",label:"Year / Week",format:"text"} ]}
  ];

  // Map by scope
  const DEFS_BY_SCOPE = {
    "Career": CAREER_CATEGORY_DEFS,
    "Season": SEASON_CATEGORY_DEFS,
    "Weekly": WEEKLY_CATEGORY_DEFS
  };

  // ---------------------------
  // Helpers
  // ---------------------------

  function areValuesEqual(a, b) {
    if (a === b) return true;
    if (a === null || b === null || a === undefined || b === undefined) return a === b;
    if (typeof a === 'number' && typeof b === 'number') {
      return Math.abs(a - b) < 0.000001;
    }
    return false;
  }

  function isPlayoffGame(m){ return m.playoffs && m.playoffs !== "N/A"; }

  // UPDATED Helper for new Matchup Types
  function getMatchupTypesForMatch(m){
    const types = new Set();
    types.add("Regular Season + Playoffs");
    if (isPlayoffGame(m)) types.add("Playoffs Only");
    else types.add("Regular Season Only");
    return types;
  }

  function ensureStatsObj(){
    return {
      games: 0,
      pointsFor: 0,
      pointsAgainst: 0,
      winsInt: 0,
      lossesInt: 0,
      tiesInt: 0,
      weeklyHighCount: 0,
      lastYear: null,
      lastWeek: null
    };
  }


  function getPlayoffRound(year, week){
    // Round mapping per league format
    // 2014–2020: R1=14, R2=15, Champ=16
    // 2021–Present: R1=15, R2=16, Champ=17
    if (year <= 2020){
      if (week === 14) return 1;
      if (week === 15) return 2;
      if (week === 16) return 3;
      return null;
    }
    if (week === 15) return 1;
    if (week === 16) return 2;
    if (week === 17) return 3;
    return null;
  }

  function ensureAccoladeObj(manager){
    return {
      manager,
      championships: 0,
      semifinalApps: 0,
      firstRoundApps: 0,
      playoffApps: 0,
      avgFinalStanding: null,
      scoringTitles: 0,
      seasons: 0,
      lastYear: null,
      lastWeek: null
    };
  }

  function buildCareerAccolades(matches, seasonStats){
    const out = {};
    MATCHUP_TYPES.forEach(t => out[t] = {});

    // Seasons-based accolades
    const byYear = {};
    (seasonStats || []).forEach(row => {
      if (!row || row.year === undefined || !row.manager) return;
      const y = Number(row.year);
      if (!byYear[y]) byYear[y] = [];
      byYear[y].push(row);
    });

    const scoringTitleWinners = {}; 
    Object.keys(byYear).forEach(yStr => {
      const y = Number(yStr);
      const rows = byYear[y] || [];
      if (!rows.length) return;
      const maxPF = Math.max(...rows.map(r => Number(r.points_for ?? r.pointsFor ?? 0)));
      const winners = new Set();
      rows.forEach(r => {
        const pf = Number(r.points_for ?? r.pointsFor ?? 0);
        if (pf === maxPF) winners.add(r.manager);
      });
      scoringTitleWinners[y] = winners;
    });

    const base = {};
    Object.keys(byYear).forEach(yStr => {
      const y = Number(yStr);
      const rows = byYear[y] || [];
      rows.forEach(r => {
        const mgr = r.manager;
        if (!base[mgr]) base[mgr] = ensureAccoladeObj(mgr);
        const a = base[mgr];
        a.seasons += 1;

        const fs = Number(r.final_standing ?? r.finalStanding);
        if (!Number.isNaN(fs) && fs > 0){
          a._finishSum = (a._finishSum || 0) + fs;
        }

        if (fs === 1) a.championships += 1;
        if (scoringTitleWinners[y] && scoringTitleWinners[y].has(mgr)) a.scoringTitles += 1;
        if (a.lastYear === null || y > a.lastYear) a.lastYear = y;
      });
    });

    Object.values(base).forEach(a => {
      const sum = a._finishSum || 0;
      a.avgFinalStanding = a.seasons ? (sum / a.seasons) : null;
      delete a._finishSum;
    });

    // Playoff participation
    const playoffByManagerYear = {}; 
    (matches || []).forEach(m => {
      if (!isPlayoffGame(m)) return;
      const round = getPlayoffRound(Number(m.year), Number(m.week));
      if (!round) return;

      const participants = [
        { manager: m.manager1 },
        { manager: m.manager2 }
      ];
      participants.forEach(p => {
        if (!p.manager) return;
        if (!playoffByManagerYear[p.manager]) playoffByManagerYear[p.manager] = {};
        if (!playoffByManagerYear[p.manager][m.year]) playoffByManagerYear[p.manager][m.year] = { r1:false, r2:false, r3:false };
        playoffByManagerYear[p.manager][m.year][`r${round}`] = true;
      });
    });

    Object.keys(playoffByManagerYear).forEach(mgr => {
      if (!base[mgr]) base[mgr] = ensureAccoladeObj(mgr);
      const years = playoffByManagerYear[mgr] || {};
      Object.keys(years).forEach(yStr => {
        const y = Number(yStr);
        const r = years[yStr];
        const madePlayoffs = !!(r.r1 || r.r2 || r.r3);
        if (!madePlayoffs) return;
        base[mgr].playoffApps += 1;

        const madeSemis = !!(r.r2 || r.r3);
        if (madeSemis) base[mgr].semifinalApps += 1;

        if (!madeSemis) base[mgr].firstRoundApps += 1;

        if (base[mgr].lastYear === null || y > base[mgr].lastYear) base[mgr].lastYear = y;
      });
    });

    MATCHUP_TYPES.forEach(t => {
      out[t] = {};
      Object.keys(base).forEach(mgr => {
        out[t][mgr] = { ...base[mgr] };
      });
    });

    return out;
  }

  function buildCareerAggregates(matches){
    const result = {};
    const weekScoresByScope = {};
    const seqByScope = {};

    MATCHUP_TYPES.forEach(scope => {
      result[scope] = {};
      weekScoresByScope[scope] = {};
      seqByScope[scope] = {};
      streaksByScope[scope] = { win: [], lose: [] };
    });

    matches.forEach(m => {
      const scopes = getMatchupTypesForMatch(m);
      const participants = [
        { manager: m.manager1, scored: m.score1, against: m.score2 },
        { manager: m.manager2, scored: m.score2, against: m.score1 }
      ];

      scopes.forEach(scope => {
        const managersStats = result[scope];
        const weekScores = weekScoresByScope[scope];
        const seqMap = seqByScope[scope];

        const weekKey = `${m.year}-${m.week}`;
        if (!weekScores[weekKey]) weekScores[weekKey] = [];

        participants.forEach(p => {
          weekScores[weekKey].push({ manager: p.manager, score: p.scored });

          if (!managersStats[p.manager]) {
            managersStats[p.manager] = { manager: p.manager, ...ensureStatsObj(), longestWinStreak:0, longestLoseStreak:0 };
            seqMap[p.manager] = [];
          }

          const s = managersStats[p.manager];
          s.games += 1;
          s.pointsFor += p.scored;
          s.pointsAgainst += p.against;

          let isWin = false;
          let isLoss = false;

          if (p.scored > p.against){ s.winsInt += 1; isWin = true; }
          else if (p.scored < p.against){ s.lossesInt += 1; isLoss = true; }
          else { s.tiesInt += 1; }

          if (s.lastYear === null || m.year > s.lastYear || (m.year === s.lastYear && m.week > s.lastWeek)){
            s.lastYear = m.year;
            s.lastWeek = m.week;
          }

          seqMap[p.manager].push({ year:m.year, week:m.week, isWin, isLoss });
        });
      });
    });

    // Weekly highs & streaks
    MATCHUP_TYPES.forEach(scope => {
      const managersStats = result[scope];
      const weekScores = weekScoresByScope[scope];
      const seqMap = seqByScope[scope];
      const scopeStreaks = streaksByScope[scope];

      // Weekly highs
      Object.keys(weekScores).forEach(weekKey => {
        const arr = weekScores[weekKey];
        if (!arr || arr.length === 0) return;
        const maxScore = Math.max(...arr.map(x => x.score));
        arr.forEach(x => {
          if (x.score === maxScore && managersStats[x.manager]) managersStats[x.manager].weeklyHighCount += 1;
        });
      });

      // Streaks
      Object.keys(seqMap).forEach(manager => {
        const seq = seqMap[manager].slice().sort((a,b) => (a.year !== b.year) ? a.year - b.year : a.week - b.week);

        let winStreaks = [];
        let loseStreaks = [];

        let startIdx = null;
        for (let i=0;i<seq.length;i++){
          const e = seq[i];
          if (e.isWin){ if (startIdx === null) startIdx = i; }
          else if (startIdx !== null){
            const endIdx = i-1;
            const start = seq[startIdx];
            const end = seq[endIdx];
            winStreaks.push({ manager, length:endIdx-startIdx+1, startYear:start.year, startWeek:start.week, endYear:end.year, endWeek:end.week });
            startIdx = null;
          }
        }
        if (startIdx !== null){
          const endIdx = seq.length-1;
          const start = seq[startIdx];
          const end = seq[endIdx];
          winStreaks.push({ manager, length:endIdx-startIdx+1, startYear:start.year, startWeek:start.week, endYear:end.year, endWeek:end.week });
        }

        startIdx = null;
        for (let i=0;i<seq.length;i++){
          const e = seq[i];
          if (e.isLoss){ if (startIdx === null) startIdx = i; }
          else if (startIdx !== null){
            const endIdx = i-1;
            const start = seq[startIdx];
            const end = seq[endIdx];
            loseStreaks.push({ manager, length:endIdx-startIdx+1, startYear:start.year, startWeek:start.week, endYear:end.year, endWeek:end.week });
            startIdx = null;
          }
        }
        if (startIdx !== null){
          const endIdx = seq.length-1;
          const start = seq[startIdx];
          const end = seq[endIdx];
          loseStreaks.push({ manager, length:endIdx-startIdx+1, startYear:start.year, startWeek:start.week, endYear:end.year, endWeek:end.week });
        }

        const longestWin = winStreaks.reduce((max,s)=>Math.max(max,s.length),0);
        const longestLose = loseStreaks.reduce((max,s)=>Math.max(max,s.length),0);
        managersStats[manager].longestWinStreak = longestWin;
        managersStats[manager].longestLoseStreak = longestLose;

        scopeStreaks.win.push(...winStreaks);
        scopeStreaks.lose.push(...loseStreaks);
      });
    });

    return result;
  }

  function buildSeasonAggregates(matches){
    const out = {};
    MATCHUP_TYPES.forEach(t => out[t] = {});

    const weekScores = {};
    MATCHUP_TYPES.forEach(t => weekScores[t] = {});

    matches.forEach(m => {
      const types = getMatchupTypesForMatch(m);
      const participants = [
        { manager: m.manager1, scored: m.score1, against: m.score2, opponent: m.manager2 },
        { manager: m.manager2, scored: m.score2, against: m.score1, opponent: m.manager1 }
      ];

      types.forEach(type => {
        const yearKey = String(m.year);
        if (!out[type][yearKey]) out[type][yearKey] = {};

        const wkKey = `${m.year}-${m.week}`;
        if (!weekScores[type][wkKey]) weekScores[type][wkKey] = [];
        participants.forEach(p => weekScores[type][wkKey].push({ manager: p.manager, score: p.scored, year: m.year }));

        participants.forEach(p => {
          if (!out[type][yearKey][p.manager]) out[type][yearKey][p.manager] = { manager:p.manager, year:m.year, ...ensureStatsObj() };

          const s = out[type][yearKey][p.manager];
          s.games += 1;
          s.pointsFor += p.scored;
          s.pointsAgainst += p.against;

          if (p.scored > p.against) s.winsInt += 1;
          else if (p.scored < p.against) s.lossesInt += 1;
          else s.tiesInt += 1;

          if (s.lastYear === null || m.year > s.lastYear || (m.year === s.lastYear && m.week > s.lastWeek)){
            s.lastYear = m.year;
            s.lastWeek = m.week;
          }
        });
      });
    });

    MATCHUP_TYPES.forEach(type => {
      Object.keys(weekScores[type]).forEach(wkKey => {
        const arr = weekScores[type][wkKey];
        if (!arr || arr.length === 0) return;
        const maxScore = Math.max(...arr.map(x => x.score));
        arr.forEach(x => {
          const yearKey = String(x.year);
          const s = out[type]?.[yearKey]?.[x.manager];
          if (s && x.score === maxScore) s.weeklyHighCount += 1;
        });
      });
    });

    return out;
  }

  let seasonStreaksByMatchupType = {};

  function buildSeasonStreaks(matches){
    const out = {};
    MATCHUP_TYPES.forEach(t => out[t] = { win: [], lose: [] });

    const seq = {}; 
    MATCHUP_TYPES.forEach(t => seq[t] = {});

    matches.forEach(m => {
      const types = getMatchupTypesForMatch(m);
      const participants = [
        { manager: m.manager1, scored: m.score1, against: m.score2 },
        { manager: m.manager2, scored: m.score2, against: m.score1 }
      ];

      types.forEach(type => {
        const yearKey = String(m.year);
        if (!seq[type][yearKey]) seq[type][yearKey] = {};

        participants.forEach(p => {
          if (!seq[type][yearKey][p.manager]) seq[type][yearKey][p.manager] = [];
          const isWin = p.scored > p.against;
          const isLoss = p.scored < p.against;
          seq[type][yearKey][p.manager].push({ year:m.year, week:m.week, isWin, isLoss });
        });
      });
    });

    MATCHUP_TYPES.forEach(type => {
      Object.keys(seq[type]).forEach(yearKey => {
        const mgrMap = seq[type][yearKey];
        Object.keys(mgrMap).forEach(manager => {
          const arr = mgrMap[manager].slice().sort((a,b)=>a.week-b.week);

          // win streaks
          let start = null;
          for (let i=0;i<arr.length;i++){
            if (arr[i].isWin){
              if (start === null) start = i;
            } else if (start !== null){
              const end = i-1;
              const length = end - start + 1;
              out[type].win.push({
                manager,
                length,
                startYear: Number(yearKey),
                startWeek: arr[start].week,
                endYear: Number(yearKey),
                endWeek: arr[end].week
              });
              start = null;
            }
          }
          if (start !== null){
            const end = arr.length-1;
            const length = end - start + 1;
            out[type].win.push({
              manager,
              length,
              startYear: Number(yearKey),
              startWeek: arr[start].week,
              endYear: Number(yearKey),
              endWeek: arr[end].week
            });
          }

          // lose streaks
          start = null;
          for (let i=0;i<arr.length;i++){
            if (arr[i].isLoss){
              if (start === null) start = i;
            } else if (start !== null){
              const end = i-1;
              const length = end - start + 1;
              out[type].lose.push({
                manager,
                length,
                startYear: Number(yearKey),
                startWeek: arr[start].week,
                endYear: Number(yearKey),
                endWeek: arr[end].week
              });
              start = null;
            }
          }
          if (start !== null){
            const end = arr.length-1;
            const length = end - start + 1;
            out[type].lose.push({
              manager,
              length,
              startYear: Number(yearKey),
              startWeek: arr[start].week,
              endYear: Number(yearKey),
              endWeek: arr[end].week
            });
          }
        });
      });
    });

    return out;
  }

  function buildWeeklyRows(matches){
    const out = {};
    MATCHUP_TYPES.forEach(t => out[t] = []);

    matches.forEach(m => {
      const types = getMatchupTypesForMatch(m);

      const rows = [
        {
          manager: m.manager1,
          opponent: m.manager2,
          scoreFor: m.score1,
          scoreAgainst: m.score2,
          margin: m.score1 - m.score2,
          isWin: m.score1 > m.score2,
          yearWeek: `${m.year} / ${m.week}`
        },
        {
          manager: m.manager2,
          opponent: m.manager1,
          scoreFor: m.score2,
          scoreAgainst: m.score1,
          margin: m.score2 - m.score1,
          isWin: m.score2 > m.score1,
          yearWeek: `${m.year} / ${m.week}`
        }
      ];

      types.forEach(type => {
        out[type].push(...rows);
      });
    });

    return out;
  }

  function enrichAggregate(stats){
    stats.ppmFor = stats.games ? (stats.pointsFor / stats.games) : 0;
    stats.ppmAgainst = stats.games ? (stats.pointsAgainst / stats.games) : 0;
    stats.winPct = stats.games ? ((stats.winsInt + (0.5 * (stats.tiesInt || 0))) / stats.games) : 0;
    stats.weeklyHighRate = stats.games ? (stats.weeklyHighCount / stats.games) : 0;
    return stats;
  }

  function resetSelect(selectEl, placeholder){
    selectEl.innerHTML = "";
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = placeholder;
    selectEl.appendChild(opt);
  }

  function populateMatchupDropdown(){
    const matchupSelect = document.getElementById("matchupTypeSelect");
    resetSelect(matchupSelect, "Select a matchup type...");
    MATCHUP_TYPES.forEach(type => {
      const opt = document.createElement("option");
      opt.value = type;
      opt.textContent = type;
      matchupSelect.appendChild(opt);
    });
  }

  function populateCategoryDropdown(scope){
    const defs = DEFS_BY_SCOPE[scope] || [];
    const categorySelect = document.getElementById("categorySelect");
    resetSelect(categorySelect, "Select a stat category...");

    const groups = [...new Set(defs.map(d => d.group))];
    groups.forEach(groupLabel => {
      const group = document.createElement("optgroup");
      group.label = groupLabel;
      defs.filter(d => d.group === groupLabel).forEach(def => {
        const opt = document.createElement("option");
        opt.value = def.label;
        opt.textContent = def.label;
        group.appendChild(opt);
      });
      categorySelect.appendChild(group);
    });
  }

  function setScopeUI(scope){
    currentScope = scope;

    // scope class on body
    document.body.classList.toggle("weekly-scope", scope === "Weekly");

    // tabs
    document.querySelectorAll(".scope-btn").forEach(btn => {
      const isActive = btn.dataset.scope === scope;
      btn.setAttribute("aria-selected", isActive ? "true" : "false");
    });

    // Titles (hints removed)
    const titleEl = document.getElementById("leaderboardTitle");
    const subtitleEl = document.getElementById("leaderboardSubtitle");
    const pillLabel = document.getElementById("pillLabel");

    if (scope === "Career"){
      titleEl.textContent = "Career Leaders";
      subtitleEl.textContent = "Career leaders across all eligible matchups";
    } else if (scope === "Season"){
      titleEl.textContent = "Season Leaders";
      subtitleEl.textContent = "Best single-season stat lines across all managers";
    } else {
      titleEl.textContent = "Weekly Records";
      subtitleEl.textContent = "Single-matchup records across all eligible matchups";
    }

    pillLabel.textContent = `${scope} · —`;

    // Dropdown repopulation
    populateCategoryDropdown(scope);
  }

  function setNoData(message){
    const headerRow = document.getElementById("headerRow");
    const tbody = document.getElementById("leaderboardBody");
    const noDataMessage = document.getElementById("noDataMessage");
    const paginationEl = document.getElementById("pagination");
    headerRow.innerHTML = "";
    tbody.innerHTML = "";
    noDataMessage.style.display = "block";
    noDataMessage.querySelector("span").textContent = message;
    if (paginationEl) paginationEl.style.display = "none";
  }

  function neutralState(){
    setNoData("Select a matchup type and stat category to see leaderboard data.");
  }

  // Pagination
  const paginationState = {
    pageSize: 25,
    currentPage: 1,
    totalRows: 0,
    totalPages: 1
  };

  function setPagination(totalRows){
    const paginationEl = document.getElementById("pagination");
    const prevBtn = document.getElementById("prevPage");
    const nextBtn = document.getElementById("nextPage");
    const pageMeta = document.getElementById("pageMeta");
    const pageStatus = document.getElementById("pageStatus");

    paginationState.totalRows = totalRows;
    paginationState.totalPages = Math.max(1, Math.ceil(totalRows / paginationState.pageSize));
    paginationState.currentPage = Math.min(paginationState.currentPage, paginationState.totalPages);

    if (paginationEl) paginationEl.style.display = (totalRows > 0) ? "flex" : "none";
    if (pageMeta) pageMeta.textContent = `Page ${paginationState.currentPage} of ${paginationState.totalPages}`;

    const start = totalRows ? ((paginationState.currentPage - 1) * paginationState.pageSize + 1) : 0;
    const end = totalRows ? Math.min(paginationState.currentPage * paginationState.pageSize, totalRows) : 0;
    if (pageStatus) pageStatus.textContent = `Showing ${start}–${end} of ${totalRows}`;

    if (prevBtn) prevBtn.disabled = paginationState.currentPage <= 1;
    if (nextBtn) nextBtn.disabled = paginationState.currentPage >= paginationState.totalPages;
  }

  function paginateRows(rows){
    const startIdx = (paginationState.currentPage - 1) * paginationState.pageSize;
    return rows.slice(startIdx, startIdx + paginationState.pageSize);
  }

  // Sorting
  const sortState = { key: null, dir: null };

  function compareValues(a, b, dir){
    if (a === b) return 0;
    if (a === null || a === undefined) return (dir === "asc") ? 1 : -1;
    if (b === null || b === undefined) return (dir === "asc") ? -1 : 1;
    if (typeof a === "string" || typeof b === "string"){
      return (dir === "asc") ? String(a).localeCompare(String(b)) : String(b).localeCompare(String(a));
    }
    return (dir === "asc") ? (a - b) : (b - a);
  }

  function formatValue(value, format, stats){
    if (format === "record"){
      const w = stats.winsInt || 0;
      const l = stats.lossesInt || 0;
      const t = stats.tiesInt || 0;
      return `${w}-${l}-${t}`;
    }
    if (value === null || value === undefined || Number.isNaN(value)) return "-";

    switch(format){
      case "percent": return (value * 100).toFixed(2);
      case "ppm": return value.toFixed(1);
      case "standing": return value.toFixed(2);
      case "marg": return (value >= 0 ? "+" : "") + value.toFixed(1);
      case "marg2": return (value >= 0 ? "+" : "") + value.toFixed(2); // 2 decimals for closest win
      case "points":
        return value.toLocaleString("en-US",{ minimumFractionDigits:2, maximumFractionDigits:2 });
      case "year": return String(value);
      case "text": return String(value);
      case "integer":
      default:
        return value.toLocaleString("en-US",{ maximumFractionDigits:0 });
    }
  }

  function getHeaderTitle(label){
    switch(label){
      case "Rank": return "Rank among managers for this stat";
      case "Manager": return "Manager name";
      case "PF": return "Total points scored (Points For)";
      case "PA": return "Total points conceded (Points Against)";
      case "PPM": return "Points per matchup (Points For / Matchups)";
      case "PAPM": return "Points Against per matchup (Points Against / Matchups)";
      case "M": return "Total matchups played";
      case "Win %": return "Winning percentage (ties count as 0.5)";
      case "Record": return "Win–Loss–Tie record";
      case "Weekly Highs": return "Count of weekly high-score finishes";
      case "Weekly High Rate": return "Weekly highs / matchups played";
      case "W": return "Total wins";
      case "L": return "Total losses";
      case "T": return "Total ties";
      case "Score": return "Points scored in the matchup";
      case "Opp Score": return "Opponent points in the matchup";
      case "MARG": return "Margin (Score - Opp Score)";
      case "Opponent": return "Opponent manager name";
      case "Year / Week": return "Year and week of the matchup";
      case "Year": return "Season year";
      case "Championships": return "Total championships won";
      case "Semifinals": return "Seasons reaching at least Round 2";
      case "Round 1": return "Seasons eliminated in Round 1";
      case "Playoffs": return "Total seasons with any playoff appearance";
      case "Avg Finish": return "Average final standing across seasons";
      case "Scoring Titles": return "Seasons finishing with most points for";
      case "Seasons": return "Total seasons tracked";
      default: return label;
    }
  }

  // ---------------------------
  // Renders: Career
  // ---------------------------

  function renderCareerAggregate(matchupType, def){
    const headerRow = document.getElementById("headerRow");
    const tbody = document.getElementById("leaderboardBody");
    const noDataMessage = document.getElementById("noDataMessage");

    const statsMap = (def.type === "accolade")
      ? (accoladesByMatchupType[matchupType] || {})
      : (aggregatesByScope[matchupType] || {});
    const allStats = Object.values(statsMap);

    if (!allStats.length){
      setNoData("Note · No data for this combination yet");
      return;
    }

    const rankingOrder = allStats.slice().sort((a,b) => {
      const aa = enrichAggregate({ ...a });
      const bb = enrichAggregate({ ...b });
      const va = aa[def.sortKey];
      const vb = bb[def.sortKey];
      let cmp = compareValues(va, vb, def.sortDir || "desc");
      if (cmp !== 0) return cmp;
      const ra = (aa.lastYear || 0) * 100 + (aa.lastWeek || 0);
      const rb = (bb.lastYear || 0) * 100 + (bb.lastWeek || 0);
      return rb - ra;
    });

    const rows = [];
    let lastValue = null;
    let currentRank = 0;
    rankingOrder.forEach((s, idx) => {
      const stats = enrichAggregate({ ...s });
      const v = stats[def.sortKey];
      
      // Robust ranking logic using areValuesEqual
      if (idx === 0) {
        currentRank = 1;
      } else if (!areValuesEqual(v, lastValue)) {
        currentRank = idx + 1;
      }
      
      lastValue = v;
      rows.push({ rank: currentRank, ...stats });
    });

    const columns = [
      { key:"rank", label:"Rank", format:"integer", sortable:true, featured:false },
      { key:"manager", label:"Manager", format:"text", sortable:true, featured:false },
      ...def.columns.map((c, idx) => ({
        key: c.key,
        label: c.label,
        format: c.format,
        polarity: c.polarity,
        sortable: true,
        featured: idx === 0
      }))
    ];

    if (!sortState.key){
      sortState.key = def.sortKey;
      sortState.dir = def.sortDir || "desc";
    }

    function applySort(r){
      const key = sortState.key;
      const dir = sortState.dir || "desc";
      return r.slice().sort((a,b) => {
        if (key === "record") return compareValues(a.winPct, b.winPct, dir);
        return compareValues(a[key], b[key], dir);
      });
    }

    const sortedRows = applySort(rows);
    paginationState.currentPage = Math.max(1, paginationState.currentPage);
    setPagination(sortedRows.length);
    const paged = paginateRows(sortedRows);

    headerRow.innerHTML = "";
    columns.forEach(col => {
      const th = document.createElement("th");
      th.textContent = col.label;
      th.className = "th-left";
      if (col.featured) th.classList.add("featured-col");
      th.title = getHeaderTitle(col.label);
      th.addEventListener("click", () => {
        if (sortState.key === col.key){
          sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
        } else {
          sortState.key = col.key;
          if (col.key === def.sortKey) sortState.dir = def.sortDir || "desc";
          else sortState.dir = "desc";
        }
        paginationState.currentPage = 1;
        renderCareerAggregate(matchupType, def);
      });
      headerRow.appendChild(th);
    });

    tbody.innerHTML = "";
    noDataMessage.style.display = "none";
    document.getElementById("pagination").style.display = "flex";

    paged.forEach((stats, i) => {
      const tr = document.createElement("tr");
      if (stats.rank === 1) tr.classList.add("top-rank");

      const rankTd = document.createElement("td");
      rankTd.className = "rank-cell";
      rankTd.textContent = stats.rank;
      tr.appendChild(rankTd);

      const managerTd = document.createElement("td");
      managerTd.className = "manager-cell";
      managerTd.textContent = stats.manager;
      tr.appendChild(managerTd);

      const featuredCol = def.columns[0];
      const contextCols = def.columns.slice(1);

      {
        const td = document.createElement("td");
        td.className = "stat-cell featured-col";
        const rawValue = (featuredCol.key === "record") ? null : stats[featuredCol.key];
        const displayValue = (featuredCol.key === "record")
          ? formatValue(null, "record", stats)
          : formatValue(rawValue, featuredCol.format, stats);

        if (featuredCol.polarity === "positivePrimary") td.classList.add("value-positive");
        if (featuredCol.polarity === "negativePrimary") td.classList.add("value-negative");

        td.textContent = displayValue;
        tr.appendChild(td);
      }

      contextCols.forEach(col => {
        const td = document.createElement("td");
        td.className = "stat-cell";
        const metricKey = col.key === "record" ? "record" : col.key;
        const displayValue = (metricKey === "record")
          ? formatValue(null, "record", stats)
          : formatValue(stats[metricKey], col.format, stats);

        if (col.polarity === "positivePrimary") td.classList.add("value-positive");
        if (col.polarity === "negativePrimary") td.classList.add("value-negative");

        td.textContent = displayValue;
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });
  }

  function renderCareerStreak(matchupType, def){
    const headerRow = document.getElementById("headerRow");
    const tbody = document.getElementById("leaderboardBody");
    const streakType = def.streakType;

    const streaks = (streaksByScope[matchupType] && streaksByScope[matchupType][streakType]) ? streaksByScope[matchupType][streakType] : [];
    if (!streaks.length){
      setNoData("Note · No streak data for this combination yet");
      return;
    }

    const ordered = streaks.slice().sort((a,b) => {
      const cmp = b.length - a.length;
      if (cmp !== 0) return cmp;
      const ra = (a.endYear * 100) + a.endWeek;
      const rb = (b.endYear * 100) + b.endWeek;
      return rb - ra;
    });

    const rows = [];
    let lastLen = null;
    let rank = 0;
    ordered.forEach((s, idx) => {
      if (idx === 0) {
        rank = 1;
      } else if (!areValuesEqual(s.length, lastLen)) { // Updated to check ties
        rank = idx + 1;
      }
      lastLen = s.length;
      rows.push({ rank, ...s });
    });

    const columns = [
      { key:"rank", label:"Rank" },
      { key:"manager", label:"Manager" },
      { key:"length", label:"Streak", format:"integer" },
      { key:"span", label:"Span", format:"text" }
    ];

    rows.forEach(r => {
      r.span = `${r.startYear} / ${r.startWeek} → ${r.endYear} / ${r.endWeek}`;
    });

    setPagination(rows.length);
    const paged = paginateRows(rows);

    headerRow.innerHTML = "";
    columns.forEach(col => {
      const th = document.createElement("th");
      th.textContent = col.label;
      th.className = "th-left";
      headerRow.appendChild(th);
    });

    tbody.innerHTML = "";
    document.getElementById("noDataMessage").style.display = "none";
    document.getElementById("pagination").style.display = "flex";

    paged.forEach(r => {
      const tr = document.createElement("tr");
      if (r.rank === 1) tr.classList.add("top-rank");

      const tdRank = document.createElement("td");
      tdRank.className = "rank-cell";
      tdRank.textContent = r.rank;
      tr.appendChild(tdRank);

      const tdMgr = document.createElement("td");
      tdMgr.className = "manager-cell";
      tdMgr.textContent = r.manager;
      tr.appendChild(tdMgr);

      const tdLen = document.createElement("td");
      tdLen.className = "stat-cell featured-col value-positive";
      tdLen.textContent = r.length;
      tr.appendChild(tdLen);

      const tdSpan = document.createElement("td");
      tdSpan.className = "stat-cell";
      tdSpan.textContent = r.span;
      tr.appendChild(tdSpan);

      tbody.appendChild(tr);
    });
  }

  // ---------------------------
  // Renders: Season
  // ---------------------------

  function flattenSeasonStats(matchupType){
    const byYear = seasonAggByMatchupType[matchupType] || {};
    const rows = [];
    Object.keys(byYear).forEach(y => {
      const mgrMap = byYear[y] || {};
      Object.values(mgrMap).forEach(s => rows.push(enrichAggregate({ ...s, year: Number(y) })));
    });
    return rows;
  }

  function renderSeasonLeaderboard(matchupType, def){
    const headerRow = document.getElementById("headerRow");
    const tbody = document.getElementById("leaderboardBody");

    const all = flattenSeasonStats(matchupType);

    if (!all.length){
      setNoData("Note · No season data for this combination yet");
      return;
    }

    let filtered = all;
    if (def.filterKey){
      filtered = all.filter(r => r[def.filterKey] === def.filterValue);
    }

    const ordered = filtered.slice().sort((a,b) => {
      const va = a[def.sortKey];
      const vb = b[def.sortKey];
      let cmp = compareValues(va, vb, def.sortDir || "desc");
      if (cmp !== 0) return cmp;
      return (b.year || 0) - (a.year || 0);
    });

    const rows = [];
    let lastVal = null;
    let rank = 0;
    ordered.forEach((s, idx) => {
      const v = s[def.sortKey];
      
      // Robust ranking logic
      if (idx === 0) {
        rank = 1;
      } else if (!areValuesEqual(v, lastVal)) {
        rank = idx + 1;
      }
      
      lastVal = v;
      rows.push({ rank, ...s });
    });

    const columns = [
      { key:"rank", label:"Rank", format:"integer", featured:false },
      { key:"manager", label:"Manager", format:"text", featured:false },
      ...def.columns.map((c, idx) => ({ ...c, featured: idx === 0 }))
    ];

    if (!sortState.key){
      sortState.key = def.sortKey;
      sortState.dir = def.sortDir || "desc";
    }

    function applySort(r){
      const key = sortState.key;
      const dir = sortState.dir || "desc";
      return r.slice().sort((a,b) => compareValues(a[key], b[key], dir));
    }

    const sortedRows = applySort(rows);
    setPagination(sortedRows.length);
    const paged = paginateRows(sortedRows);

    headerRow.innerHTML = "";
    columns.forEach(col => {
      const th = document.createElement("th");
      th.textContent = col.label;
      th.className = "th-left";
      if (col.featured) th.classList.add("featured-col");
      th.title = getHeaderTitle(col.label);
      th.addEventListener("click", () => {
        if (sortState.key === col.key){
          sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
        } else {
          sortState.key = col.key;
          sortState.dir = (col.key === def.sortKey) ? (def.sortDir || "desc") : "desc";
        }
        paginationState.currentPage = 1;
        renderSeasonLeaderboard(matchupType, def);
      });
      headerRow.appendChild(th);
    });

    tbody.innerHTML = "";
    document.getElementById("noDataMessage").style.display = "none";
    document.getElementById("pagination").style.display = "flex";

    paged.forEach(r => {
      const tr = document.createElement("tr");
      if (r.rank === 1) tr.classList.add("top-rank");

      const tdRank = document.createElement("td");
      tdRank.className = "rank-cell";
      tdRank.textContent = r.rank;
      tr.appendChild(tdRank);

      const tdMgr = document.createElement("td");
      tdMgr.className = "manager-cell";
      tdMgr.textContent = r.manager;
      tr.appendChild(tdMgr);

      def.columns.forEach((col, idx) => {
        const td = document.createElement("td");
        td.className = "stat-cell" + (idx === 0 ? " featured-col" : "");
        const display = (col.key === "record")
          ? formatValue(null, "record", r)
          : formatValue(r[col.key], col.format, r);

        if (col.polarity === "positivePrimary") td.classList.add("value-positive");
        if (col.polarity === "negativePrimary") td.classList.add("value-negative");

        td.textContent = display;
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });
  }

  function renderSeasonStreak(matchupType, def){
    const headerRow = document.getElementById("headerRow");
    const tbody = document.getElementById("leaderboardBody");
    const streakType = def.streakType;

    const streaks = (seasonStreaksByMatchupType[matchupType] && seasonStreaksByMatchupType[matchupType][streakType]) ? seasonStreaksByMatchupType[matchupType][streakType] : [];
    if (!streaks.length){
      setNoData("Note · No season streak data for this combination yet");
      return;
    }

    const ordered = streaks.slice().sort((a,b) => {
      const cmp = b.length - a.length;
      if (cmp !== 0) return cmp;
      const ra = (a.endYear * 100) + a.endWeek;
      const rb = (b.endYear * 100) + b.endWeek;
      return rb - ra;
    });

    const rows = [];
    let lastLen = null;
    let rank = 0;
    ordered.forEach((s, idx) => {
      if (idx === 0) {
        rank = 1;
      } else if (!areValuesEqual(s.length, lastLen)) { // Updated to check ties
        rank = idx + 1;
      }
      lastLen = s.length;
      rows.push({ rank, ...s, span: `${s.startYear} / ${s.startWeek} → ${s.endYear} / ${s.endWeek}` });
    });

    setPagination(rows.length);
    const paged = paginateRows(rows);

    headerRow.innerHTML = "";
    ["Rank","Manager","Streak","Span"].forEach(label => {
      const th = document.createElement("th");
      th.textContent = label;
      th.className = "th-left";
      headerRow.appendChild(th);
    });

    tbody.innerHTML = "";
    document.getElementById("noDataMessage").style.display = "none";
    document.getElementById("pagination").style.display = "flex";

    paged.forEach(r => {
      const tr = document.createElement("tr");
      if (r.rank === 1) tr.classList.add("top-rank");

      const tdRank = document.createElement("td");
      tdRank.className = "rank-cell";
      tdRank.textContent = r.rank;
      tr.appendChild(tdRank);

      const tdMgr = document.createElement("td");
      tdMgr.className = "manager-cell";
      tdMgr.textContent = r.manager;
      tr.appendChild(tdMgr);

      const tdLen = document.createElement("td");
      tdLen.className = "stat-cell featured-col value-positive";
      tdLen.textContent = r.length;
      tr.appendChild(tdLen);

      const tdSpan = document.createElement("td");
      tdSpan.className = "stat-cell";
      tdSpan.textContent = r.span;
      tr.appendChild(tdSpan);

      tbody.appendChild(tr);
    });
  }

  // ---------------------------
  // Renders: Weekly
  // ---------------------------

  function renderWeeklyLeaderboard(matchupType, def){
    const headerRow = document.getElementById("headerRow");
    const tbody = document.getElementById("leaderboardBody");
    const all = weeklyRowsByMatchupType[matchupType] || [];
    if (!all.length){
      setNoData("Note · No weekly data for this combination yet");
      return;
    }

    let filtered = all;
    if (def.filterKey){
      filtered = all.filter(r => r[def.filterKey] === def.filterValue);
    }

    const ordered = filtered.slice().sort((a,b) => compareValues(a[def.sortKey], b[def.sortKey], def.sortDir || "desc"));

    const rows = [];
    let lastVal = null;
    let rank = 0;
    ordered.forEach((s, idx) => {
      const v = s[def.sortKey];
      
      // Robust ranking logic
      if (idx === 0) {
        rank = 1;
      } else if (!areValuesEqual(v, lastVal)) {
        rank = idx + 1;
      }
      
      lastVal = v;
      rows.push({ rank, ...s });
    });

    const columns = [
      { key:"rank", label:"Rank", format:"integer", featured:false },
      { key:"manager", label:"Manager", format:"text", featured:false },
      ...def.columns.map((c, idx) => ({ ...c, featured: idx === 0 }))
    ];

    if (!sortState.key){
      sortState.key = def.sortKey;
      sortState.dir = def.sortDir || "desc";
    }

    function applySort(r){
      const key = sortState.key;
      const dir = sortState.dir || "desc";
      return r.slice().sort((a,b) => compareValues(a[key], b[key], dir));
    }

    const sortedRows = applySort(rows);
    setPagination(sortedRows.length);
    const paged = paginateRows(sortedRows);

    headerRow.innerHTML = "";
    columns.forEach(col => {
      const th = document.createElement("th");
      th.textContent = col.label;
      th.className = "th-left";
      if (col.featured) th.classList.add("featured-col");
      th.title = getHeaderTitle(col.label);
      th.addEventListener("click", () => {
        if (sortState.key === col.key){
          sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
        } else {
          sortState.key = col.key;
          sortState.dir = (col.key === def.sortKey) ? (def.sortDir || "desc") : "desc";
        }
        paginationState.currentPage = 1;
        renderWeeklyLeaderboard(matchupType, def);
      });
      headerRow.appendChild(th);
    });

    tbody.innerHTML = "";
    document.getElementById("noDataMessage").style.display = "none";
    document.getElementById("pagination").style.display = "flex";

    paged.forEach(r => {
      const tr = document.createElement("tr");
      if (r.rank === 1) tr.classList.add("top-rank");

      const tdRank = document.createElement("td");
      tdRank.className = "rank-cell";
      tdRank.textContent = r.rank;
      tr.appendChild(tdRank);

      const tdMgr = document.createElement("td");
      tdMgr.className = "manager-cell";
      tdMgr.textContent = r.manager;
      tr.appendChild(tdMgr);

      def.columns.forEach((col, idx) => {
        const td = document.createElement("td");
        td.className = "stat-cell" + (idx === 0 ? " featured-col" : "");
        const display = formatValue(r[col.key], col.format, r);
        if (col.polarity === "positivePrimary") td.classList.add("value-positive");
        if (col.polarity === "negativePrimary") td.classList.add("value-negative");
        td.textContent = display;
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });
  }

  // ---------------------------
  // Main render
  // ---------------------------

  function renderLeaderboard(matchupType, categoryLabel){
    const defs = DEFS_BY_SCOPE[currentScope] || [];
    const def = defs.find(d => d.label === categoryLabel);
    if (!def) return;

    const titleEl = document.getElementById("leaderboardTitle");
    const subtitleEl = document.getElementById("leaderboardSubtitle");
    const pillLabel = document.getElementById("pillLabel");

    titleEl.textContent = def.label;
    pillLabel.textContent = `${currentScope} · ${matchupType}`;

    if (
      currentScope === "Career" &&
      matchupType === "Playoffs Only" &&
      def.group === "Weekly Dominance"
    ){
      setNoData("Note · Weekly high scores are only tracked for Regular Season matchups.");
      subtitleEl.textContent = "";
      return;
    }

    if (currentScope === "Career"){
      subtitleEl.textContent = (def.type === "streak")
        ? "Career streaks with exact start–end span"
        : "Career leaders across all eligible matchups";

      if (def.type === "streak") renderCareerStreak(matchupType, def);
      else renderCareerAggregate(matchupType, def);
      return;
    }

    if (currentScope === "Season"){
      subtitleEl.textContent = (def.type === "seasonStreak")
        ? "Season streaks with exact start–end span"
        : "Best single-season stat lines across all managers";
      if (def.type === "seasonStreak") renderSeasonStreak(matchupType, def);
      else renderSeasonLeaderboard(matchupType, def);
      return;
    }

    subtitleEl.textContent = "Single-matchup records across all eligible matchups";
    renderWeeklyLeaderboard(matchupType, def);
  }

  // ---------------------------
  // Load JSON & init
  // ---------------------------

  async function loadMatchups(){
    try{
      const res = await fetch("league-scores.json");
      if (!res.ok){
        console.error("Failed to load league-scores.json:", res.status, res.statusText);
        return [];
      }
      return await res.json();
    } catch(err){
      console.error("Error loading league-scores.json", err);
      return [];
    }
  }

  async function loadSeasonStats(){
    try{
      const res = await fetch("final-standings.json");
      if (!res.ok){
        console.error("Failed to load final-standings.json:", res.status, res.statusText);
        return [];
      }
      return await res.json();
    } catch(err){
      console.error("Error loading final-standings.json", err);
      return [];
    }
  }

  document.addEventListener("DOMContentLoaded", async () => {
    populateMatchupDropdown();
    populateCategoryDropdown("Career");

    rawMatchups = await loadMatchups();
    aggregatesByScope = buildCareerAggregates(rawMatchups);
    seasonAggByMatchupType = buildSeasonAggregates(rawMatchups);
    weeklyRowsByMatchupType = buildWeeklyRows(rawMatchups);
    seasonStreaksByMatchupType = buildSeasonStreaks(rawMatchups);

    seasonStatsRaw = await loadSeasonStats();
    accoladesByMatchupType = buildCareerAccolades(rawMatchups, seasonStatsRaw);

    const matchupSelect = document.getElementById("matchupTypeSelect");
    const categorySelect = document.getElementById("categorySelect");

    // DEFAULT SETTINGS ON LOAD
    matchupSelect.value = "Regular Season + Playoffs";
    categorySelect.value = "Most Points For";

    function rerenderCurrent(){
      const matchupType = matchupSelect.value;
      const categoryLabel = categorySelect.value;
      if (!matchupType || !categoryLabel){
        neutralState();
        return;
      }
      renderLeaderboard(matchupType, categoryLabel);
    }

    const prevBtn = document.getElementById("prevPage");
    const nextBtn = document.getElementById("nextPage");

    if (prevBtn) prevBtn.addEventListener("click", () => {
      if (paginationState.currentPage > 1){
        paginationState.currentPage -= 1;
        rerenderCurrent();
      }
    });

    if (nextBtn) nextBtn.addEventListener("click", () => {
      paginationState.currentPage += 1;
      rerenderCurrent();
    });

    // scope tabs
    document.querySelectorAll(".scope-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const scope = btn.dataset.scope;
        // logic to check if current cat exists in new scope
        const previousCategory = categorySelect.value;
        
        sortState.key = null;
        sortState.dir = null;
        paginationState.currentPage = 1;
        
        setScopeUI(scope);

        // check availability
        let found = false;
        for (let i = 0; i < categorySelect.options.length; i++) {
          if (categorySelect.options[i].value === previousCategory) {
            found = true;
            break;
          }
        }

        if (found) {
          categorySelect.value = previousCategory;
          rerenderCurrent();
        } else {
          neutralState();
        }
      });
    });

    matchupSelect.addEventListener("change", () => {
      paginationState.currentPage = 1;
      sortState.key = null;
      sortState.dir = null;
      rerenderCurrent();
    });

    categorySelect.addEventListener("change", () => {
      paginationState.currentPage = 1;
      sortState.key = null;
      sortState.dir = null;
      rerenderCurrent();
    });

    // Initial Render
    rerenderCurrent();
  });
</script>
<script src="nav-loader.js"></script>
</body>
</html>
