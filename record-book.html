<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Record Book – LWFFL</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#0f1a2e;
    --panel2:#0c1628;
    --border:rgba(148,163,184,.18);
    --text:#e5e7eb;
    --muted:#9ca3af;
    --soft:#cbd5e1;
    --accent:rgba(56,189,248,.85);
    --accent2:rgba(34,211,238,.75);
    --good:#22c55e;
    --bad:#ef4444;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1200px 600px at 30% -10%, rgba(56,189,248,.18), transparent 60%),
                radial-gradient(900px 500px at 80% 0%, rgba(34,211,238,.12), transparent 55%),
                var(--bg);
    color:var(--text);
  }
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  header{display:flex;align-items:flex-end;justify-content:space-between;gap:16px;margin-bottom:14px;flex-wrap:wrap}
  h1{margin:0;font-size:28px;letter-spacing:.04em}
  .sub{color:var(--muted);font-size:13px;max-width:720px;line-height:1.35}
  .card{
    background: linear-gradient(180deg, rgba(15,26,46,.92), rgba(12,22,40,.92));
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow: 0 16px 40px rgba(0,0,0,.28);
    overflow:hidden;
  }
  .controls{padding:14px 14px 10px 14px;border-bottom:1px solid var(--border)}
  .tabs{
    display:flex;gap:8px;flex-wrap:wrap;
    margin-bottom:12px;
  }
  .tab{
    appearance:none;border:1px solid var(--border);
    background:rgba(2,6,23,.35);
    color:var(--soft);
    padding:8px 12px;border-radius:999px;
    font-weight:700;font-size:12px;letter-spacing:.12em;text-transform:uppercase;
    cursor:pointer;
  }
  .tab[aria-selected="true"]{
    border-color: rgba(56,189,248,.55);
    box-shadow: 0 0 0 2px rgba(56,189,248,.18);
    color: #f8fafc;
    background: rgba(56,189,248,.08);
  }
  .row{
    display:flex;gap:10px;flex-wrap:wrap;align-items:center;
  }
  label{font-size:11px;color:var(--muted);letter-spacing:.12em;text-transform:uppercase}
  .field{display:flex;flex-direction:column;gap:6px;min-width:220px;flex:1}
  select{
    width:100%;
    padding:10px 12px;border-radius:12px;
    border:1px solid var(--border);
    background: rgba(2,6,23,.55);
    color:var(--text);
    outline:none;
    font-weight:650;
  }
  .pill{
    margin-left:auto;
    padding:10px 12px;border-radius:12px;
    border:1px solid var(--border);
    background: rgba(2,6,23,.35);
    color:var(--soft);
    font-size:12px;
    letter-spacing:.06em;
    white-space:nowrap;
  }
  .meta{padding:12px 14px 0 14px}
  .meta h2{margin:0;font-size:14px;letter-spacing:.08em;text-transform:uppercase}
  .meta p{margin:6px 0 0 0;color:var(--muted);font-size:13px;line-height:1.35}
  .tablewrap{padding:12px 14px 16px 14px}
  .scroll{
    width:100%;
    overflow:auto;
    border:1px solid var(--border);
    border-radius:14px;
    background: rgba(2,6,23,.28);
  }
  table{
    width:100%;
    border-collapse:separate;
    border-spacing:0;
    min-width: 760px;
  }
  thead th{
    position:sticky;top:0;
    background: rgba(12,22,40,.95);
    border-bottom:1px solid var(--border);
    color:var(--soft);
    font-size:11px;
    letter-spacing:.14em;
    text-transform:uppercase;
    padding:10px 12px;
    text-align:left !important;
    cursor:pointer;
    user-select:none;
    white-space:nowrap;
  }
  tbody td{
    padding:10px 12px;
    border-bottom:1px solid rgba(148,163,184,.10);
    color:var(--text);
    font-size:13px;
    text-align:left !important;
    white-space:nowrap;
  }
  tbody tr:hover td{background: rgba(56,189,248,.06)}
  .rank{color:#94a3b8;font-weight:800}
  .top1 td{background: rgba(34,197,94,.08)}
  .featured-col{background: rgba(56,189,248,.10)}
  thead th.featured-col{background: rgba(56,189,248,.14)}
  .good{color:var(--good);font-weight:800}
  .bad{color:var(--bad);font-weight:800}
  .pagination{
    display:flex;gap:10px;align-items:center;justify-content:flex-end;flex-wrap:wrap;
    margin-top:10px;padding-top:10px;border-top:1px solid var(--border);
  }
  .pagebtn{
    border:1px solid var(--border);
    background: rgba(2,6,23,.45);
    color:var(--text);
    padding:8px 12px;border-radius:12px;
    cursor:pointer;font-weight:800;letter-spacing:.08em;text-transform:uppercase;font-size:11px;
  }
  .pagebtn:disabled{opacity:.45;cursor:not-allowed}
  .pagemeta{color:var(--muted);font-size:12px;letter-spacing:.08em}
  .nodata{
    display:none;
    padding:14px;
    border:1px dashed rgba(148,163,184,.28);
    border-radius:14px;
    color:var(--muted);
    background: rgba(2,6,23,.25);
  }
  @media (max-width:640px){
    h1{font-size:24px}
    .field{min-width: 160px}
    table{min-width: 680px}
    .pill{width:100%;text-align:left}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Record Book</h1>
        <div class="sub">Three scopes: Career, Season, Weekly. Use Matchup Type + Stat Category to explore. Click any column header to sort. 25 rows per page.</div>
      </div>
    </header>

    <div class="card">
      <div class="controls">
        <div class="tabs" role="tablist" aria-label="Scopes">
          <button class="tab" data-scope="Career" aria-selected="true">Career</button>
          <button class="tab" data-scope="Season" aria-selected="false">Season</button>
          <button class="tab" data-scope="Weekly" aria-selected="false">Weekly</button>
        </div>

        <div class="row">
          <div class="field">
            <label for="matchupType">Matchup Type</label>
            <select id="matchupType">
              <option>Regular Season + Playoffs</option>
              <option>Regular Season Only</option>
              <option>Playoffs Only</option>
            </select>
          </div>
          <div class="field">
            <label for="category">Stat Category</label>
            <select id="category"></select>
          </div>
          <div class="pill" id="pill">Career · Regular Season + Playoffs</div>
        </div>
      </div>

      <div class="meta">
        <h2 id="title">Career Leaders</h2>
        <p id="subtitle">Aggregate performance across all seasons.</p>
      </div>

      <div class="tablewrap">
        <div class="nodata" id="nodata">No data available for this combination.</div>

        <div class="scroll">
          <table aria-label="Leaderboard">
            <thead><tr id="thead"></tr></thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <div class="pagination" id="pagination" style="display:none">
          <button class="pagebtn" id="prev">Prev</button>
          <div class="pagemeta" id="pagemeta">Page 1 of 1</div>
          <button class="pagebtn" id="next">Next</button>
          <div class="pagemeta" id="pagestatus">Showing 0–0 of 0</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* -----------------------------
   Data loading
------------------------------ */
const DATA_URL = "league-scores.json";

/** Expected minimal row fields:
 *  year (int), week (int),
 *  manager1 (away), score1 (number),
 *  manager2 (home), score2 (number),
 *  playoffs? (boolean or string)
 */
function toNumber(x){
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}
function parseBoolish(x){
  if (typeof x === "boolean") return x;
  if (typeof x === "number") return x !== 0;
  if (typeof x === "string"){
    const s = x.trim().toLowerCase();
    if (["true","t","yes","y","1","playoffs","playoff"].includes(s)) return true;
    if (["false","f","no","n","0","regular"].includes(s)) return false;
  }
  return false;
}
function normalizeRow(r){
  const year = Number(r.year);
  const week = Number(r.week);
  const manager1 = String(r.manager1 ?? "").trim();
  const manager2 = String(r.manager2 ?? "").trim();
  const score1 = toNumber(r.score1);
  const score2 = toNumber(r.score2);
  const playoffs = parseBoolish(r.playoffs ?? r.isPlayoff ?? r.playoff ?? false);
  if (!Number.isFinite(year) || !Number.isFinite(week) || !manager1 || !manager2 || score1===null || score2===null){
    return null;
  }
  return { year, week, manager1, manager2, score1, score2, playoffs };
}

async function loadData(){
  const res = await fetch(DATA_URL, { cache: "no-store" });
  if (!res.ok) throw new Error("Failed to load " + DATA_URL);
  const raw = await res.json();
  if (!Array.isArray(raw)) throw new Error("league-scores.json must be an array");
  const rows = raw.map(normalizeRow).filter(Boolean);
  return rows;
}

/* -----------------------------
   UI State
------------------------------ */
const SCOPES = ["Career","Season","Weekly"];
const MATCHUP_TYPES = ["Regular Season + Playoffs","Regular Season Only","Playoffs Only"];

let currentScope = "Career";
let allMatchups = [];

const pagination = { pageSize:25, currentPage:1, total:0 };

let sortState = { key:null, dir:"desc" }; // dir: asc|desc
let currentDef = null;

function resetPage(){ pagination.currentPage = 1; }

function updatePill(){
  const mt = document.getElementById("matchupType").value;
  document.getElementById("pill").textContent = `${currentScope} · ${mt}`;
}

function showNoData(msg){
  const nd = document.getElementById("nodata");
  nd.textContent = msg || "No data available for this combination.";
  nd.style.display = "block";
  document.getElementById("pagination").style.display = "none";
  document.getElementById("thead").innerHTML = "";
  document.getElementById("tbody").innerHTML = "";
}
function hideNoData(){
  document.getElementById("nodata").style.display = "none";
}

/* -----------------------------
   Matchup Type filtering
------------------------------ */
function inType(m, matchupType){
  if (matchupType === "Regular Season + Playoffs") return true;
  if (matchupType === "Regular Season Only") return !m.playoffs;
  if (matchupType === "Playoffs Only") return !!m.playoffs;
  return true;
}

/* -----------------------------
   Formatting helpers
------------------------------ */
function fmtYear(y){ return String(y); } // no commas
function fmtPoints2(x){
  return x.toLocaleString("en-US",{minimumFractionDigits:2, maximumFractionDigits:2});
}
function fmtAvg1(x){
  return x.toLocaleString("en-US",{minimumFractionDigits:1, maximumFractionDigits:1});
}
function fmtMarg1(x){
  const s = (x>=0?"+":"") + fmtAvg1(x);
  return s;
}
function fmtRecord(w,l,t){ return `${w}-${l}-${t}`; }

/* -----------------------------
   Category definitions
------------------------------ */
const CAREER_CATEGORIES = [
  { label:"Most Wins", type:"careerAgg", featured:{key:"wins", label:"Wins", kind:"int"} },
  { label:"Best Win %", type:"careerAgg", featured:{key:"winPct", label:"Win %", kind:"pct"} },
  { label:"Most PF", type:"careerAgg", featured:{key:"pf", label:"PF", kind:"points"} },
  { label:"Most PA", type:"careerAgg", featured:{key:"pa", label:"PA", kind:"points"} },
  { label:"Highest PF Per Matchup (PFPM)", type:"careerAgg", featured:{key:"pfpm", label:"PFPM", kind:"avg"} },
  { label:"Lowest PA Per Matchup (PAPM)", type:"careerAgg", featured:{key:"papm", label:"PAPM", kind:"avg", polarity:"lowBetter"} },
  { label:"Highest Points Against Per Matchup (PAPM)", type:"careerAgg", featured:{key:"papm", label:"PAPM", kind:"avg"} },
  { label:"Highest MARG", type:"careerAgg", featured:{key:"marg", label:"MARG", kind:"marg"} },
  { label:"Longest Winning Streak", type:"careerStreak", streak:"win" },
  { label:"Longest Losing Streak", type:"careerStreak", streak:"lose" },
];

const SEASON_CATEGORIES = [
  { label:"Most Wins", type:"seasonAgg", featured:{key:"wins", label:"Wins", kind:"int"} },
  { label:"Best Win %", type:"seasonAgg", featured:{key:"winPct", label:"Win %", kind:"pct"} },
  { label:"Most PF", type:"seasonAgg", featured:{key:"pf", label:"PF", kind:"points"} },
  { label:"Most PA", type:"seasonAgg", featured:{key:"pa", label:"PA", kind:"points"} },
  { label:"Highest PF Per Matchup (PFPM)", type:"seasonAgg", featured:{key:"pfpm", label:"PFPM", kind:"avg"} },
  { label:"Lowest Points Against Per Matchup (PAPM)", type:"seasonAgg", featured:{key:"papm", label:"PAPM", kind:"avg", polarity:"lowBetter"} },
  { label:"Highest Points Against Per Matchup (PAPM)", type:"seasonAgg", featured:{key:"papm", label:"PAPM", kind:"avg"} },
  { label:"Highest MARG", type:"seasonAgg", featured:{key:"marg", label:"MARG", kind:"marg"} },
  { label:"Longest Winning Streak", type:"seasonStreak", streak:"win" },
  { label:"Longest Losing Streak", type:"seasonStreak", streak:"lose" },
];

const WEEKLY_CATEGORIES = [
  { label:"Highest Score", type:"weekly", featured:{key:"scoreFor", label:"Score", kind:"points"} },
  { label:"Lowest Score", type:"weekly", featured:{key:"scoreFor", label:"Score", kind:"points", polarity:"lowBetter"} },
  { label:"Biggest MARG", type:"weekly", featured:{key:"margin", label:"MARG", kind:"marg"} },
  { label:"Closest Match (smallest MARG)", type:"weekly", featured:{key:"absMargin", label:"MARG", kind:"marg", polarity:"lowBetter"} },
];

function getScopeDefs(scope){
  if (scope==="Career") return CAREER_CATEGORIES;
  if (scope==="Season") return SEASON_CATEGORIES;
  return WEEKLY_CATEGORIES;
}

/* -----------------------------
   Computations
------------------------------ */
function buildCareerAgg(matchups, matchupType){
  const map = new Map();
  const add = (mgr, scored, against) => {
    if (!map.has(mgr)){
      map.set(mgr, { manager:mgr, games:0, wins:0, losses:0, ties:0, pf:0, pa:0, marg:0 });
    }
    const s = map.get(mgr);
    s.games += 1;
    if (scored > against) s.wins += 1;
    else if (scored < against) s.losses += 1;
    else s.ties += 1;
    s.pf += scored;
    s.pa += against;
    s.marg += (scored - against);
  };

  matchups.forEach(m => {
    if (!inType(m, matchupType)) return;
    add(m.manager1, m.score1, m.score2);
    add(m.manager2, m.score2, m.score1);
  });

  return Array.from(map.values()).map(s => ({
    ...s,
    record: fmtRecord(s.wins, s.losses, s.ties),
    winPct: (s.wins + 0.5*s.ties) / Math.max(1, s.games),
    pfpm: s.pf / Math.max(1, s.games),
    papm: s.pa / Math.max(1, s.games),
    marg: s.marg / Math.max(1, s.games) // avg margin per matchup
  }));
}

function buildSeasonAgg(matchups, matchupType){
  const map = new Map(); // key: year|manager
  const add = (year, mgr, scored, against) => {
    const key = `${year}||${mgr}`;
    if (!map.has(key)){
      map.set(key, { year, manager:mgr, games:0, wins:0, losses:0, ties:0, pf:0, pa:0, margSum:0 });
    }
    const s = map.get(key);
    s.games += 1;
    if (scored > against) s.wins += 1;
    else if (scored < against) s.losses += 1;
    else s.ties += 1;
    s.pf += scored;
    s.pa += against;
    s.margSum += (scored - against);
  };

  matchups.forEach(m => {
    if (!inType(m, matchupType)) return;
    add(m.year, m.manager1, m.score1, m.score2);
    add(m.year, m.manager2, m.score2, m.score1);
  });

  return Array.from(map.values()).map(s => ({
    ...s,
    record: fmtRecord(s.wins, s.losses, s.ties),
    winPct: (s.wins + 0.5*s.ties) / Math.max(1, s.games),
    pfpm: s.pf / Math.max(1, s.games),
    papm: s.pa / Math.max(1, s.games),
    marg: s.margSum / Math.max(1, s.games)
  }));
}

function buildWeeklyRows(matchups, matchupType){
  const rows = [];
  matchups.forEach(m => {
    if (!inType(m, matchupType)) return;
    rows.push({
      year:m.year, week:m.week,
      manager:m.manager1, opponent:m.manager2,
      scoreFor:m.score1, scoreAgainst:m.score2,
      margin: m.score1 - m.score2,
      absMargin: Math.abs(m.score1 - m.score2),
      playoffs: m.playoffs
    });
    rows.push({
      year:m.year, week:m.week,
      manager:m.manager2, opponent:m.manager1,
      scoreFor:m.score2, scoreAgainst:m.score1,
      margin: m.score2 - m.score1,
      absMargin: Math.abs(m.score2 - m.score1),
      playoffs: m.playoffs
    });
  });
  return rows.map(r => ({
    ...r,
    yearWeek: `${fmtYear(r.year)} Wk ${r.week}`
  }));
}

function buildCareerStreaks(matchups, matchupType){
  // Longest consecutive wins/losses across all weeks (within manager). We'll sort by year,week globally.
  const byMgr = new Map();
  const add = (mgr, year, week, isWin, isLoss) => {
    if (!byMgr.has(mgr)) byMgr.set(mgr, []);
    byMgr.get(mgr).push({ year, week, isWin, isLoss });
  };
  matchups.forEach(m => {
    if (!inType(m, matchupType)) return;
    add(m.manager1, m.year, m.week, m.score1>m.score2, m.score1<m.score2);
    add(m.manager2, m.year, m.week, m.score2>m.score1, m.score2<m.score1);
  });

  const streaks = { win:[], lose:[] };
  for (const [mgr, arr] of byMgr.entries()){
    arr.sort((a,b)=> a.year===b.year ? a.week-b.week : a.year-b.year);

    // win streak
    let start=null;
    for (let i=0;i<arr.length;i++){
      if (arr[i].isWin){
        if (start===null) start=i;
      } else if (start!==null){
        const end=i-1;
        streaks.win.push({ manager:mgr, length:end-start+1, start:arr[start], end:arr[end] });
        start=null;
      }
    }
    if (start!==null){
      const end=arr.length-1;
      streaks.win.push({ manager:mgr, length:end-start+1, start:arr[start], end:arr[end] });
    }

    // loss streak
    start=null;
    for (let i=0;i<arr.length;i++){
      if (arr[i].isLoss){
        if (start===null) start=i;
      } else if (start!==null){
        const end=i-1;
        streaks.lose.push({ manager:mgr, length:end-start+1, start:arr[start], end:arr[end] });
        start=null;
      }
    }
    if (start!==null){
      const end=arr.length-1;
      streaks.lose.push({ manager:mgr, length:end-start+1, start:arr[start], end:arr[end] });
    }
  }
  return streaks;
}

function buildSeasonStreaks(matchups, matchupType){
  // streaks constrained within year
  const byYearMgr = new Map(); // key year||mgr
  const add = (year, mgr, week, isWin, isLoss) => {
    const key = `${year}||${mgr}`;
    if (!byYearMgr.has(key)) byYearMgr.set(key, []);
    byYearMgr.get(key).push({ year, week, isWin, isLoss });
  };
  matchups.forEach(m => {
    if (!inType(m, matchupType)) return;
    add(m.year, m.manager1, m.week, m.score1>m.score2, m.score1<m.score2);
    add(m.year, m.manager2, m.week, m.score2>m.score1, m.score2<m.score1);
  });

  const streaks = { win:[], lose:[] };
  for (const [key, arr] of byYearMgr.entries()){
    const [yearStr, mgr] = key.split("||");
    arr.sort((a,b)=>a.week-b.week);

    let start=null;
    for (let i=0;i<arr.length;i++){
      if (arr[i].isWin){
        if (start===null) start=i;
      } else if (start!==null){
        const end=i-1;
        streaks.win.push({ year:Number(yearStr), manager:mgr, length:end-start+1, startWeek:arr[start].week, endWeek:arr[end].week });
        start=null;
      }
    }
    if (start!==null){
      const end=arr.length-1;
      streaks.win.push({ year:Number(yearStr), manager:mgr, length:end-start+1, startWeek:arr[start].week, endWeek:arr[end].week });
    }

    start=null;
    for (let i=0;i<arr.length;i++){
      if (arr[i].isLoss){
        if (start===null) start=i;
      } else if (start!==null){
        const end=i-1;
        streaks.lose.push({ year:Number(yearStr), manager:mgr, length:end-start+1, startWeek:arr[start].week, endWeek:arr[end].week });
        start=null;
      }
    }
    if (start!==null){
      const end=arr.length-1;
      streaks.lose.push({ year:Number(yearStr), manager:mgr, length:end-start+1, startWeek:arr[start].week, endWeek:arr[end].week });
    }
  }
  return streaks;
}

/* -----------------------------
   Sorting helpers
------------------------------ */
function compare(a,b,key){
  const av = a[key];
  const bv = b[key];
  if (av === bv) return 0;
  // nulls last
  if (av === null || av === undefined) return 1;
  if (bv === null || bv === undefined) return -1;

  if (typeof av === "number" && typeof bv === "number") return av - bv;
  return String(av).localeCompare(String(bv));
}
function sortRows(rows){
  if (!sortState.key) return rows;
  const dir = sortState.dir === "asc" ? 1 : -1;
  return rows.slice().sort((a,b)=>{
    const c = compare(a,b,sortState.key);
    if (c!==0) return c*dir;
    // stable-ish tiebreakers
    if ("year" in a && "year" in b && a.year!==b.year) return (b.year-a.year); // recency
    if ("week" in a && "week" in b && a.week!==b.week) return (b.week-a.week);
    if ("manager" in a && "manager" in b) return a.manager.localeCompare(b.manager);
    return 0;
  });
}

/* -----------------------------
   Pagination
------------------------------ */
function paginate(rows){
  const total = rows.length;
  pagination.total = total;
  const totalPages = Math.max(1, Math.ceil(total / pagination.pageSize));
  if (pagination.currentPage > totalPages) pagination.currentPage = totalPages;
  if (pagination.currentPage < 1) pagination.currentPage = 1;

  const start = (pagination.currentPage-1)*pagination.pageSize;
  const end = Math.min(total, start + pagination.pageSize);
  const pageRows = rows.slice(start, end);

  const pg = document.getElementById("pagination");
  if (total === 0){
    pg.style.display="none";
  } else {
    pg.style.display="flex";
    document.getElementById("pagemeta").textContent = `Page ${pagination.currentPage} of ${totalPages}`;
    document.getElementById("pagestatus").textContent = `Showing ${start+1}–${end} of ${total}`;
    document.getElementById("prev").disabled = pagination.currentPage<=1;
    document.getElementById("next").disabled = pagination.currentPage>=totalPages;
  }
  return pageRows;
}

/* -----------------------------
   Rendering
------------------------------ */
function setHeader(columns, featuredKey){
  const thead = document.getElementById("thead");
  thead.innerHTML = "";
  columns.forEach(col=>{
    const th = document.createElement("th");
    th.textContent = col.label;
    th.dataset.key = col.key;
    if (col.key === featuredKey) th.classList.add("featured-col");
    th.onclick = () => {
      // sort toggle
      if (sortState.key === col.key){
        sortState.dir = sortState.dir === "asc" ? "desc" : "asc";
      } else {
        sortState.key = col.key;
        // default dir: desc for numbers, asc for text
        sortState.dir = col.kind==="text" ? "asc" : "desc";
      }
      resetPage();
      render();
    };
    thead.appendChild(th);
  });
}

function setRows(rows, columns, featuredKey, topRankKey){
  const tbody = document.getElementById("tbody");
  tbody.innerHTML = "";
  rows.forEach((r, i)=>{
    const tr = document.createElement("tr");
    if (r._rank === 1) tr.classList.add("top1");
    columns.forEach(col=>{
      const td = document.createElement("td");
      if (col.key === "rank") td.classList.add("rank");
      if (col.key === featuredKey) td.classList.add("featured-col");
      let v = r[col.key];

      if (col.format === "points") td.textContent = fmtPoints2(v);
      else if (col.format === "avg") td.textContent = fmtAvg1(v);
      else if (col.format === "marg") td.textContent = fmtMarg1(v);
      else if (col.format === "pct") td.textContent = fmtAvg1(v*100) + "%";
      else td.textContent = (v===null || v===undefined) ? "" : String(v);

      // color helpers
      if (col.key === featuredKey && col.polarity === "lowBetter"){
        // For low-better featured columns (e.g., PAPM, lowest score): highlight green-ish when lower relative not trivial
        // Keep simple: do nothing here.
      }
      tbody.appendChild(tr);
      tr.appendChild(td);
    });
  });
}

function rankWithTies(rows, featuredKey, dir){
  // returns new array with _rank assigned based on featuredKey
  const sortedForRank = rows.slice().sort((a,b)=>{
    const c = compare(a,b,featuredKey);
    return (dir==="asc" ? c : -c);
  });
  let rank = 0;
  let prev = null;
  sortedForRank.forEach((r, idx)=>{
    const v = r[featuredKey];
    if (prev === null || v !== prev){
      rank = idx+1;
      prev = v;
    }
    r._rank = rank;
  });
  return rows;
}

function render(){
  updatePill();
  hideNoData();

  const matchupType = document.getElementById("matchupType").value;
  const categoryLabel = document.getElementById("category").value;
  const defs = getScopeDefs(currentScope);
  currentDef = defs.find(d=>d.label===categoryLabel) || defs[0];

  if (!currentDef){
    showNoData("No categories available.");
    return;
  }

  const title = document.getElementById("title");
  const subtitle = document.getElementById("subtitle");

  let rows = [];
  let columns = [];
  let featuredKey = null;

  // default sort key when changing categories
  if (!sortState.key){
    // will set after columns known
  }

  if (currentScope==="Career"){
    if (currentDef.type==="careerAgg"){
      title.textContent = "Career Leaders";
      subtitle.textContent = "Aggregate performance across all seasons.";
      const all = buildCareerAgg(allMatchups, matchupType);

      // base columns
      featuredKey = currentDef.featured.key;
      columns = [
        { key:"rank", label:"Rank", kind:"int" },
        { key:"manager", label:"Manager", kind:"text" },
        { key:"record", label:"Record", kind:"text" },
        { key:"games", label:"GP", kind:"int" },
        { key:"wins", label:"Wins", kind:"int" },
        { key:"losses", label:"Losses", kind:"int" },
        { key:"ties", label:"Ties", kind:"int" },
      ];

      // Add featured + contextual stats
      const contextual = [
        { key:"pf", label:"PF", kind:"num", format:"points" },
        { key:"pa", label:"PA", kind:"num", format:"points" },
        { key:"pfpm", label:"PFPM", kind:"num", format:"avg" },
        { key:"papm", label:"PAPM", kind:"num", format:"avg" },
        { key:"marg", label:"MARG", kind:"num", format:"marg" },
        { key:"winPct", label:"Win %", kind:"num", format:"pct" },
      ];

      // reorder: put featured column early (after manager) if not already present
      const featuredCol = contextual.find(c=>c.key===featuredKey) || columns.find(c=>c.key===featuredKey);
      const restContext = contextual.filter(c=>c.key!==featuredKey);

      // Ensure record etc stay; insert featured after Record maybe
      columns = columns.concat([]);
      if (featuredCol && !columns.some(c=>c.key===featuredCol.key)){
        columns.push(featuredCol);
      }
      columns = columns.concat(restContext);

      rows = all;

      // ranking direction
      const rankDir = (currentDef.featured.polarity==="lowBetter") ? "asc" : "desc";
      rankWithTies(rows, featuredKey, rankDir);

      // default sort: featured
      if (!sortState.key) sortState = { key: featuredKey, dir: rankDir };

    } else {
      title.textContent = "Career Streaks";
      subtitle.textContent = "Longest streaks across all seasons.";
      const streaks = buildCareerStreaks(allMatchups, matchupType);
      const list = (currentDef.streak==="win") ? streaks.win : streaks.lose;

      rows = list.map(s=>({
        manager:s.manager,
        length:s.length,
        span: `${fmtYear(s.start.year)} Wk ${s.start.week} – ${fmtYear(s.end.year)} Wk ${s.end.week}`
      }));

      featuredKey = "length";
      columns = [
        { key:"rank", label:"Rank", kind:"int" },
        { key:"manager", label:"Manager", kind:"text" },
        { key:"length", label: currentDef.streak==="win" ? "Win Streak" : "Loss Streak", kind:"int" },
        { key:"span", label:"Span", kind:"text" },
      ];

      // rank
      rankWithTies(rows, "length", "desc");
      if (!sortState.key) sortState = { key:"length", dir:"desc" };
    }
  }

  if (currentScope==="Season"){
    if (currentDef.type==="seasonAgg"){
      title.textContent = "Season Leaders";
      subtitle.textContent = "Best single-season stat lines across all managers.";
      const all = buildSeasonAgg(allMatchups, matchupType);

      featuredKey = currentDef.featured.key;
      columns = [
        { key:"rank", label:"Rank", kind:"int" },
        { key:"year", label:"Year", kind:"int" },
        { key:"manager", label:"Manager", kind:"text" },
        { key:"record", label:"Record", kind:"text" },
        { key:"games", label:"GP", kind:"int" },
        { key:"wins", label:"Wins", kind:"int" },
        { key:"losses", label:"Losses", kind:"int" },
        { key:"ties", label:"Ties", kind:"int" },
      ];
      const contextual = [
        { key:"pf", label:"PF", kind:"num", format:"points" },
        { key:"pa", label:"PA", kind:"num", format:"points" },
        { key:"pfpm", label:"PFPM", kind:"num", format:"avg" },
        { key:"papm", label:"PAPM", kind:"num", format:"avg" },
        { key:"marg", label:"MARG", kind:"num", format:"marg" },
        { key:"winPct", label:"Win %", kind:"num", format:"pct" },
      ];
      const featuredCol = contextual.find(c=>c.key===featuredKey);
      const rest = contextual.filter(c=>c.key!==featuredKey);
      if (featuredCol) columns.push(featuredCol);
      columns = columns.concat(rest);

      rows = all;

      const rankDir = (currentDef.featured.polarity==="lowBetter") ? "asc" : "desc";
      rankWithTies(rows, featuredKey, rankDir);
      if (!sortState.key) sortState = { key: featuredKey, dir: rankDir };

    } else {
      title.textContent = "Season Streaks";
      subtitle.textContent = "Season streaks with exact start–end span.";
      const streaks = buildSeasonStreaks(allMatchups, matchupType);
      const list = (currentDef.streak==="win") ? streaks.win : streaks.lose;

      rows = list.map(s=>({
        year:s.year,
        manager:s.manager,
        length:s.length,
        span: `${fmtYear(s.year)} Wk ${s.startWeek}–Wk ${s.endWeek}`
      }));
      featuredKey = "length";
      columns = [
        { key:"rank", label:"Rank", kind:"int" },
        { key:"year", label:"Year", kind:"int" },
        { key:"manager", label:"Manager", kind:"text" },
        { key:"length", label: currentDef.streak==="win" ? "Win Streak" : "Loss Streak", kind:"int" },
        { key:"span", label:"Span", kind:"text" },
      ];
      rankWithTies(rows, "length", "desc");
      if (!sortState.key) sortState = { key:"length", dir:"desc" };
    }
  }

  if (currentScope==="Weekly"){
    title.textContent = "Weekly Records";
    subtitle.textContent = "Single-matchup records across all managers.";
    const all = buildWeeklyRows(allMatchups, matchupType);

    featuredKey = currentDef.featured.key;
    rows = all;

    columns = [
      { key:"rank", label:"Rank", kind:"int" },
      { key:"yearWeek", label:"Year / Week", kind:"text" },
      { key:"manager", label:"Manager", kind:"text" },
      { key:"opponent", label:"Opponent", kind:"text" },
      { key:"scoreFor", label:"Score", kind:"num", format:"points" },
      { key:"scoreAgainst", label:"Opp Score", kind:"num", format:"points" },
      { key:"margin", label:"MARG", kind:"num", format:"marg" },
      { key:"playoffs", label:"Playoffs", kind:"text" },
    ];

    // rank based on featured metric; special case absMargin when showing closest match
    const rankKey = featuredKey;
    const rankDir = (currentDef.featured.polarity==="lowBetter") ? "asc" : "desc";
    rankWithTies(rows, rankKey, rankDir);
    if (!sortState.key) sortState = { key: rankKey, dir: rankDir };
  }

  if (!rows.length){
    showNoData("Note · No data for this selection.");
    return;
  }

  // Apply sorting and pagination
  const sorted = sortRows(rows);
  const pageRows = paginate(sorted);

  // Build header (sortable)
  setHeader(columns, featuredKey);

  // Render rows
  // Ensure rank displayed from _rank (computed earlier)
  const displayRows = pageRows.map(r => ({ ...r, rank: r._rank }));
  setRows(displayRows, columns, featuredKey);

  // Featured header style
  // Add featured-col class to header cell
  Array.from(document.querySelectorAll("thead th")).forEach(th=>{
    if (th.dataset.key === featuredKey) th.classList.add("featured-col");
  });
}

/* -----------------------------
   Dropdown population
------------------------------ */
function populateCategory(){
  const catSel = document.getElementById("category");
  const defs = getScopeDefs(currentScope);
  catSel.innerHTML = "";
  defs.forEach(d=>{
    const opt = document.createElement("option");
    opt.value = d.label;
    opt.textContent = d.label;
    catSel.appendChild(opt);
  });
  catSel.value = defs[0]?.label || "";
}

/* -----------------------------
   Wire up
------------------------------ */
function setScope(scope){
  currentScope = scope;
  // toggle selected
  document.querySelectorAll(".tab").forEach(btn=>{
    const active = btn.dataset.scope === scope;
    btn.setAttribute("aria-selected", active ? "true" : "false");
  });
  // Reset per user: keep matchup type across scopes, but reset category to first + page 1
  populateCategory();
  sortState = { key:null, dir:"desc" };
  resetPage();
  updatePill();
  render();
}

document.getElementById("prev").addEventListener("click", ()=>{
  if (pagination.currentPage>1){
    pagination.currentPage -= 1;
    render();
  }
});
document.getElementById("next").addEventListener("click", ()=>{
  pagination.currentPage += 1;
  render();
});

document.getElementById("matchupType").addEventListener("change", ()=>{
  resetPage();
  sortState = { key:null, dir:"desc" };
  render();
});
document.getElementById("category").addEventListener("change", ()=>{
  resetPage();
  sortState = { key:null, dir:"desc" };
  render();
});
document.querySelectorAll(".tab").forEach(btn=>{
  btn.addEventListener("click", ()=> setScope(btn.dataset.scope));
});

// Init
(async function init(){
  try{
    // default matchup type to Regular Season + Playoffs on first load
    document.getElementById("matchupType").value = "Regular Season + Playoffs";
    populateCategory();
    allMatchups = await loadData();
    updatePill();
    render();
  }catch(err){
    console.error(err);
    showNoData("Error loading data. Check console + make sure league-scores.json is next to this HTML and is valid JSON.");
  }
})();
</script>
</body>
</html>
